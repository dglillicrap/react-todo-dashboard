{"ast":null,"code":"/*! @azure/msal-common v15.13.0 2025-09-24 */\n'use strict';\n\nimport { BaseClient } from './BaseClient.mjs';\nimport { wasClockTurnedBack, isTokenExpired } from '../utils/TimeUtils.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { CacheOutcome } from '../utils/Constants.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { getTenantFromAuthorityString } from '../authority/Authority.mjs';\nimport { tokenRefreshRequired, noAccountInSilentRequest, authTimeNotFound } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/** @internal */\nclass SilentFlowClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n  }\n  /**\r\n   * Retrieves token from cache or throws an error if it must be refreshed.\r\n   * @param request\r\n   */\n  async acquireCachedToken(request) {\n    var _this$performanceClie;\n    (_this$performanceClie = this.performanceClient) === null || _this$performanceClie === void 0 || _this$performanceClie.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);\n    let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;\n    if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {\n      // Must refresh due to present force_refresh flag.\n      this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);\n      throw createClientAuthError(tokenRefreshRequired);\n    }\n    // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n    if (!request.account) {\n      throw createClientAuthError(noAccountInSilentRequest);\n    }\n    const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);\n    const tokenKeys = this.cacheManager.getTokenKeys();\n    const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId);\n    if (!cachedAccessToken) {\n      // must refresh due to non-existent access_token\n      this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);\n      throw createClientAuthError(tokenRefreshRequired);\n    } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n      // must refresh due to the expires_in value\n      this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);\n      throw createClientAuthError(tokenRefreshRequired);\n    } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {\n      // must refresh (in the background) due to the refresh_in value\n      lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;\n      // don't throw ClientAuthError.createRefreshRequiredError(), return cached token instead\n    }\n    const environment = request.authority || this.authority.getPreferredCache();\n    const cacheRecord = {\n      account: this.cacheManager.getAccount(this.cacheManager.generateAccountKey(request.account), request.correlationId),\n      accessToken: cachedAccessToken,\n      idToken: this.cacheManager.getIdToken(request.account, request.correlationId, tokenKeys, requestTenantId, this.performanceClient),\n      refreshToken: null,\n      appMetadata: this.cacheManager.readAppMetadataFromCache(environment)\n    };\n    this.setCacheOutcome(lastCacheOutcome, request.correlationId);\n    if (this.config.serverTelemetryManager) {\n      this.config.serverTelemetryManager.incrementCacheHits();\n    }\n    return [await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request), lastCacheOutcome];\n  }\n  setCacheOutcome(cacheOutcome, correlationId) {\n    var _this$serverTelemetry, _this$performanceClie2;\n    (_this$serverTelemetry = this.serverTelemetryManager) === null || _this$serverTelemetry === void 0 || _this$serverTelemetry.setCacheOutcome(cacheOutcome);\n    (_this$performanceClie2 = this.performanceClient) === null || _this$performanceClie2 === void 0 || _this$performanceClie2.addFields({\n      cacheOutcome: cacheOutcome\n    }, correlationId);\n    if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {\n      this.logger.info(\"Token refresh is required due to cache outcome: \".concat(cacheOutcome));\n    }\n  }\n  /**\r\n   * Helper function to build response object from the CacheRecord\r\n   * @param cacheRecord\r\n   */\n  async generateResultFromCacheRecord(cacheRecord, request) {\n    var _this$performanceClie3;\n    (_this$performanceClie3 = this.performanceClient) === null || _this$performanceClie3 === void 0 || _this$performanceClie3.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);\n    let idTokenClaims;\n    if (cacheRecord.idToken) {\n      idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);\n    }\n    // token max_age check\n    if (request.maxAge || request.maxAge === 0) {\n      var _idTokenClaims;\n      const authTime = (_idTokenClaims = idTokenClaims) === null || _idTokenClaims === void 0 ? void 0 : _idTokenClaims.auth_time;\n      if (!authTime) {\n        throw createClientAuthError(authTimeNotFound);\n      }\n      checkMaxAge(authTime, request.maxAge);\n    }\n    return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);\n  }\n}\nexport { SilentFlowClient };","map":{"version":3,"names":["SilentFlowClient","BaseClient","constructor","configuration","performanceClient","acquireCachedToken","request","_this$performanceClie","addQueueMeasurement","PerformanceEvents","SilentFlowClientAcquireCachedToken","correlationId","lastCacheOutcome","CacheOutcome","NOT_APPLICABLE","forceRefresh","config","cacheOptions","claimsBasedCachingEnabled","StringUtils","isEmptyObj","claims","setCacheOutcome","FORCE_REFRESH_OR_CLAIMS","createClientAuthError","tokenRefreshRequired","account","noAccountInSilentRequest","requestTenantId","tenantId","getTenantFromAuthorityString","authority","tokenKeys","cacheManager","getTokenKeys","cachedAccessToken","getAccessToken","NO_CACHED_ACCESS_TOKEN","wasClockTurnedBack","cachedAt","isTokenExpired","expiresOn","systemOptions","tokenRenewalOffsetSeconds","CACHED_ACCESS_TOKEN_EXPIRED","refreshOn","PROACTIVELY_REFRESHED","environment","getPreferredCache","cacheRecord","getAccount","generateAccountKey","accessToken","idToken","getIdToken","refreshToken","appMetadata","readAppMetadataFromCache","serverTelemetryManager","incrementCacheHits","invokeAsync","generateResultFromCacheRecord","bind","SilentFlowClientGenerateResultFromCacheRecord","logger","cacheOutcome","_this$serverTelemetry","_this$performanceClie2","addFields","info","concat","_this$performanceClie3","idTokenClaims","extractTokenClaims","secret","cryptoInterface","base64Decode","maxAge","_idTokenClaims","authTime","auth_time","authTimeNotFound","checkMaxAge","ResponseHandler","generateAuthenticationResult","cryptoUtils"],"sources":["C:\\_Projects\\DGL_ToDo\\react_todo_dashboard2\\node_modules\\@azure\\msal-common\\src\\client\\SilentFlowClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient.js\";\nimport { ClientConfiguration } from \"../config/ClientConfiguration.js\";\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport * as TimeUtils from \"../utils/TimeUtils.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError.js\";\nimport { ResponseHandler } from \"../response/ResponseHandler.js\";\nimport { CacheRecord } from \"../cache/entities/CacheRecord.js\";\nimport { CacheOutcome } from \"../utils/Constants.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { StringUtils } from \"../utils/StringUtils.js\";\nimport { checkMaxAge, extractTokenClaims } from \"../account/AuthToken.js\";\nimport { TokenClaims } from \"../account/TokenClaims.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport { invokeAsync } from \"../utils/FunctionWrappers.js\";\nimport { getTenantFromAuthorityString } from \"../authority/Authority.js\";\n\n/** @internal */\nexport class SilentFlowClient extends BaseClient {\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n    }\n\n    /**\n     * Retrieves token from cache or throws an error if it must be refreshed.\n     * @param request\n     */\n    async acquireCachedToken(\n        request: CommonSilentFlowRequest\n    ): Promise<[AuthenticationResult, CacheOutcome]> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.SilentFlowClientAcquireCachedToken,\n            request.correlationId\n        );\n        let lastCacheOutcome: CacheOutcome = CacheOutcome.NOT_APPLICABLE;\n\n        if (\n            request.forceRefresh ||\n            (!this.config.cacheOptions.claimsBasedCachingEnabled &&\n                !StringUtils.isEmptyObj(request.claims))\n        ) {\n            // Must refresh due to present force_refresh flag.\n            this.setCacheOutcome(\n                CacheOutcome.FORCE_REFRESH_OR_CLAIMS,\n                request.correlationId\n            );\n            throw createClientAuthError(\n                ClientAuthErrorCodes.tokenRefreshRequired\n            );\n        }\n\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n        if (!request.account) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.noAccountInSilentRequest\n            );\n        }\n\n        const requestTenantId =\n            request.account.tenantId ||\n            getTenantFromAuthorityString(request.authority);\n        const tokenKeys = this.cacheManager.getTokenKeys();\n        const cachedAccessToken = this.cacheManager.getAccessToken(\n            request.account,\n            request,\n            tokenKeys,\n            requestTenantId\n        );\n\n        if (!cachedAccessToken) {\n            // must refresh due to non-existent access_token\n            this.setCacheOutcome(\n                CacheOutcome.NO_CACHED_ACCESS_TOKEN,\n                request.correlationId\n            );\n            throw createClientAuthError(\n                ClientAuthErrorCodes.tokenRefreshRequired\n            );\n        } else if (\n            TimeUtils.wasClockTurnedBack(cachedAccessToken.cachedAt) ||\n            TimeUtils.isTokenExpired(\n                cachedAccessToken.expiresOn,\n                this.config.systemOptions.tokenRenewalOffsetSeconds\n            )\n        ) {\n            // must refresh due to the expires_in value\n            this.setCacheOutcome(\n                CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED,\n                request.correlationId\n            );\n            throw createClientAuthError(\n                ClientAuthErrorCodes.tokenRefreshRequired\n            );\n        } else if (\n            cachedAccessToken.refreshOn &&\n            TimeUtils.isTokenExpired(cachedAccessToken.refreshOn, 0)\n        ) {\n            // must refresh (in the background) due to the refresh_in value\n            lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;\n\n            // don't throw ClientAuthError.createRefreshRequiredError(), return cached token instead\n        }\n\n        const environment =\n            request.authority || this.authority.getPreferredCache();\n        const cacheRecord: CacheRecord = {\n            account: this.cacheManager.getAccount(\n                this.cacheManager.generateAccountKey(request.account),\n                request.correlationId\n            ),\n            accessToken: cachedAccessToken,\n            idToken: this.cacheManager.getIdToken(\n                request.account,\n                request.correlationId,\n                tokenKeys,\n                requestTenantId,\n                this.performanceClient\n            ),\n            refreshToken: null,\n            appMetadata:\n                this.cacheManager.readAppMetadataFromCache(environment),\n        };\n\n        this.setCacheOutcome(lastCacheOutcome, request.correlationId);\n\n        if (this.config.serverTelemetryManager) {\n            this.config.serverTelemetryManager.incrementCacheHits();\n        }\n\n        return [\n            await invokeAsync(\n                this.generateResultFromCacheRecord.bind(this),\n                PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )(cacheRecord, request),\n            lastCacheOutcome,\n        ];\n    }\n\n    private setCacheOutcome(\n        cacheOutcome: CacheOutcome,\n        correlationId: string\n    ): void {\n        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);\n        this.performanceClient?.addFields(\n            {\n                cacheOutcome: cacheOutcome,\n            },\n            correlationId\n        );\n        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {\n            this.logger.info(\n                `Token refresh is required due to cache outcome: ${cacheOutcome}`\n            );\n        }\n    }\n\n    /**\n     * Helper function to build response object from the CacheRecord\n     * @param cacheRecord\n     */\n    private async generateResultFromCacheRecord(\n        cacheRecord: CacheRecord,\n        request: CommonSilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,\n            request.correlationId\n        );\n        let idTokenClaims: TokenClaims | undefined;\n        if (cacheRecord.idToken) {\n            idTokenClaims = extractTokenClaims(\n                cacheRecord.idToken.secret,\n                this.config.cryptoInterface.base64Decode\n            );\n        }\n\n        // token max_age check\n        if (request.maxAge || request.maxAge === 0) {\n            const authTime = idTokenClaims?.auth_time;\n            if (!authTime) {\n                throw createClientAuthError(\n                    ClientAuthErrorCodes.authTimeNotFound\n                );\n            }\n\n            checkMaxAge(authTime, request.maxAge);\n        }\n\n        return ResponseHandler.generateAuthenticationResult(\n            this.cryptoUtils,\n            this.authority,\n            cacheRecord,\n            true,\n            request,\n            idTokenClaims\n        );\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;AAAA;;;AAGG;AAsBH;AACM,MAAOA,gBAAiB,SAAQC,UAAU;EAC5CC,WACIA,CAAAC,aAAkC,EAClCC,iBAAsC;IAEtC,KAAK,CAACD,aAAa,EAAEC,iBAAiB,CAAC;;EAG3C;;;AAGG;EACH,MAAMC,kBAAkBA,CACpBC,OAAgC;IAAA,IAAAC,qBAAA;IAEhC,CAAAA,qBAAA,OAAI,CAACH,iBAAiB,cAAAG,qBAAA,eAAtBA,qBAAA,CAAwBC,mBAAmB,CACvCC,iBAAiB,CAACC,kCAAkC,EACpDJ,OAAO,CAACK,aAAa,CACxB;IACD,IAAIC,gBAAgB,GAAiBC,YAAY,CAACC,cAAc;IAEhE,IACIR,OAAO,CAACS,YAAY,IACnB,CAAC,IAAI,CAACC,MAAM,CAACC,YAAY,CAACC,yBAAyB,IAChD,CAACC,WAAW,CAACC,UAAU,CAACd,OAAO,CAACe,MAAM,CAAE,EAC9C;;MAEE,IAAI,CAACC,eAAe,CAChBT,YAAY,CAACU,uBAAuB,EACpCjB,OAAO,CAACK,aAAa,CACxB;MACD,MAAMa,qBAAqB,CACvBC,oBAAyC,CAC5C;IACJ;;IAGD,IAAI,CAACnB,OAAO,CAACoB,OAAO,EAAE;MAClB,MAAMF,qBAAqB,CACvBG,wBAA6C,CAChD;IACJ;IAED,MAAMC,eAAe,GACjBtB,OAAO,CAACoB,OAAO,CAACG,QAAQ,IACxBC,4BAA4B,CAACxB,OAAO,CAACyB,SAAS,CAAC;IACnD,MAAMC,SAAS,GAAG,IAAI,CAACC,YAAY,CAACC,YAAY,EAAE;IAClD,MAAMC,iBAAiB,GAAG,IAAI,CAACF,YAAY,CAACG,cAAc,CACtD9B,OAAO,CAACoB,OAAO,EACfpB,OAAO,EACP0B,SAAS,EACTJ,eAAe,CAClB;IAED,IAAI,CAACO,iBAAiB,EAAE;;MAEpB,IAAI,CAACb,eAAe,CAChBT,YAAY,CAACwB,sBAAsB,EACnC/B,OAAO,CAACK,aAAa,CACxB;MACD,MAAMa,qBAAqB,CACvBC,oBAAyC,CAC5C;IACJ,OAAM,IACHa,kBAA4B,CAACH,iBAAiB,CAACI,QAAQ,CAAC,IACxDC,cAAwB,CACpBL,iBAAiB,CAACM,SAAS,EAC3B,IAAI,CAACzB,MAAM,CAAC0B,aAAa,CAACC,yBAAyB,CACtD,EACH;;MAEE,IAAI,CAACrB,eAAe,CAChBT,YAAY,CAAC+B,2BAA2B,EACxCtC,OAAO,CAACK,aAAa,CACxB;MACD,MAAMa,qBAAqB,CACvBC,oBAAyC,CAC5C;IACJ,OAAM,IACHU,iBAAiB,CAACU,SAAS,IAC3BL,cAAwB,CAACL,iBAAiB,CAACU,SAAS,EAAE,CAAC,CAAC,EAC1D;;MAEEjC,gBAAgB,GAAGC,YAAY,CAACiC,qBAAqB;;IAGxD;IAED,MAAMC,WAAW,GACbzC,OAAO,CAACyB,SAAS,IAAI,IAAI,CAACA,SAAS,CAACiB,iBAAiB,EAAE;IAC3D,MAAMC,WAAW,GAAgB;MAC7BvB,OAAO,EAAE,IAAI,CAACO,YAAY,CAACiB,UAAU,CACjC,IAAI,CAACjB,YAAY,CAACkB,kBAAkB,CAAC7C,OAAO,CAACoB,OAAO,CAAC,EACrDpB,OAAO,CAACK,aAAa,CACxB;MACDyC,WAAW,EAAEjB,iBAAiB;MAC9BkB,OAAO,EAAE,IAAI,CAACpB,YAAY,CAACqB,UAAU,CACjChD,OAAO,CAACoB,OAAO,EACfpB,OAAO,CAACK,aAAa,EACrBqB,SAAS,EACTJ,eAAe,EACf,IAAI,CAACxB,iBAAiB,CACzB;MACDmD,YAAY,EAAE,IAAI;MAClBC,WAAW,EACP,IAAI,CAACvB,YAAY,CAACwB,wBAAwB,CAACV,WAAW;KAC7D;IAED,IAAI,CAACzB,eAAe,CAACV,gBAAgB,EAAEN,OAAO,CAACK,aAAa,CAAC;IAE7D,IAAI,IAAI,CAACK,MAAM,CAAC0C,sBAAsB,EAAE;MACpC,IAAI,CAAC1C,MAAM,CAAC0C,sBAAsB,CAACC,kBAAkB,EAAE;IAC1D;IAED,OAAO,CACH,MAAMC,WAAW,CACb,IAAI,CAACC,6BAA6B,CAACC,IAAI,CAAC,IAAI,CAAC,EAC7CrD,iBAAiB,CAACsD,6CAA6C,EAC/D,IAAI,CAACC,MAAM,EACX,IAAI,CAAC5D,iBAAiB,EACtBE,OAAO,CAACK,aAAa,CACxB,CAACsC,WAAW,EAAE3C,OAAO,CAAC,EACvBM,gBAAgB,CACnB;;EAGGU,eAAeA,CACnB2C,YAA0B,EAC1BtD,aAAqB;IAAA,IAAAuD,qBAAA,EAAAC,sBAAA;IAErB,CAAAD,qBAAA,OAAI,CAACR,sBAAsB,cAAAQ,qBAAA,eAA3BA,qBAAA,CAA6B5C,eAAe,CAAC2C,YAAY,CAAC;IAC1D,CAAAE,sBAAA,OAAI,CAAC/D,iBAAiB,cAAA+D,sBAAA,eAAtBA,sBAAA,CAAwBC,SAAS,CAC7B;MACIH,YAAY,EAAEA;KACjB,EACDtD,aAAa,CAChB;IACD,IAAIsD,YAAY,KAAKpD,YAAY,CAACC,cAAc,EAAE;MAC9C,IAAI,CAACkD,MAAM,CAACK,IAAI,oDAAAC,MAAA,CACuCL,YAAY,CAAE,CACpE;IACJ;;EAGL;;;AAGG;EACK,MAAMJ,6BAA6BA,CACvCZ,WAAwB,EACxB3C,OAAgC;IAAA,IAAAiE,sBAAA;IAEhC,CAAAA,sBAAA,OAAI,CAACnE,iBAAiB,cAAAmE,sBAAA,eAAtBA,sBAAA,CAAwB/D,mBAAmB,CACvCC,iBAAiB,CAACsD,6CAA6C,EAC/DzD,OAAO,CAACK,aAAa,CACxB;IACD,IAAI6D,aAAsC;IAC1C,IAAIvB,WAAW,CAACI,OAAO,EAAE;MACrBmB,aAAa,GAAGC,kBAAkB,CAC9BxB,WAAW,CAACI,OAAO,CAACqB,MAAM,EAC1B,IAAI,CAAC1D,MAAM,CAAC2D,eAAe,CAACC,YAAY,CAC3C;IACJ;;IAGD,IAAItE,OAAO,CAACuE,MAAM,IAAIvE,OAAO,CAACuE,MAAM,KAAK,CAAC,EAAE;MAAA,IAAAC,cAAA;MACxC,MAAMC,QAAQ,IAAAD,cAAA,GAAGN,aAAa,cAAAM,cAAA,uBAAbA,cAAA,CAAeE,SAAS;MACzC,IAAI,CAACD,QAAQ,EAAE;QACX,MAAMvD,qBAAqB,CACvByD,gBAAqC,CACxC;MACJ;MAEDC,WAAW,CAACH,QAAQ,EAAEzE,OAAO,CAACuE,MAAM,CAAC;IACxC;IAED,OAAOM,eAAe,CAACC,4BAA4B,CAC/C,IAAI,CAACC,WAAW,EAChB,IAAI,CAACtD,SAAS,EACdkB,WAAW,EACX,IAAI,EACJ3C,OAAO,EACPkE,aAAa,CAChB;;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}