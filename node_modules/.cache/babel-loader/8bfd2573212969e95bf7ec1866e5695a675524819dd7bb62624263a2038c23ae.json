{"ast":null,"code":"/*! @azure/msal-common v15.13.0 2025-09-24 */\n'use strict';\n\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { StringUtils } from './StringUtils.mjs';\nimport { hashNotDeserialized } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Canonicalizes a URL by making it lowercase and ensuring it ends with /\r\n * Inlined version of UrlString.canonicalizeUri to avoid circular dependency\r\n * @param url - URL to canonicalize\r\n * @returns Canonicalized URL\r\n */\nfunction canonicalizeUrl(url) {\n  if (!url) {\n    return url;\n  }\n  let lowerCaseUrl = url.toLowerCase();\n  if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n    lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n  } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n    lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n  }\n  if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n    lowerCaseUrl += \"/\";\n  }\n  return lowerCaseUrl;\n}\n/**\r\n * Parses hash string from given string. Returns empty string if no hash symbol is found.\r\n * @param hashString\r\n */\nfunction stripLeadingHashOrQuery(responseString) {\n  if (responseString.startsWith(\"#/\")) {\n    return responseString.substring(2);\n  } else if (responseString.startsWith(\"#\") || responseString.startsWith(\"?\")) {\n    return responseString.substring(1);\n  }\n  return responseString;\n}\n/**\r\n * Returns URL hash as server auth code response object.\r\n */\nfunction getDeserializedResponse(responseString) {\n  // Check if given hash is empty\n  if (!responseString || responseString.indexOf(\"=\") < 0) {\n    return null;\n  }\n  try {\n    // Strip the # or ? symbol if present\n    const normalizedResponse = stripLeadingHashOrQuery(responseString);\n    // If # symbol was not present, above will return empty string, so give original hash value\n    const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));\n    // Check for known response properties\n    if (deserializedHash.code || deserializedHash.ear_jwe || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {\n      return deserializedHash;\n    }\n  } catch (e) {\n    throw createClientAuthError(hashNotDeserialized);\n  }\n  return null;\n}\n/**\r\n * Utility to create a URL from the params map\r\n */\nfunction mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {\n  const queryParameterArray = new Array();\n  parameters.forEach((value, key) => {\n    if (!encodeExtraParams && extraQueryParameters && key in extraQueryParameters) {\n      queryParameterArray.push(`${key}=${value}`);\n    } else {\n      queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);\n    }\n  });\n  return queryParameterArray.join(\"&\");\n}\n/**\r\n * Normalizes URLs for comparison by removing hash, canonicalizing,\r\n * and ensuring consistent URL encoding in query parameters.\r\n * This fixes redirect loops when URLs contain encoded characters like apostrophes (%27).\r\n * @param url - URL to normalize\r\n * @returns Normalized URL string for comparison\r\n */\nfunction normalizeUrlForComparison(url) {\n  if (!url) {\n    return url;\n  }\n  // Remove hash first\n  const urlWithoutHash = url.split(\"#\")[0];\n  try {\n    // Parse the URL to handle encoding consistently\n    const urlObj = new URL(urlWithoutHash);\n    /*\r\n     * Reconstruct the URL with properly decoded query parameters\r\n     * This ensures that %27 and ' are treated as equivalent\r\n     */\n    const normalizedUrl = urlObj.origin + urlObj.pathname + urlObj.search;\n    // Apply canonicalization logic inline to avoid circular dependency\n    return canonicalizeUrl(normalizedUrl);\n  } catch (e) {\n    // Fallback to original logic if URL parsing fails\n    return canonicalizeUrl(urlWithoutHash);\n  }\n}\nexport { getDeserializedResponse, mapToQueryString, normalizeUrlForComparison, stripLeadingHashOrQuery };","map":{"version":3,"names":["canonicalizeUrl","url","lowerCaseUrl","toLowerCase","StringUtils","endsWith","slice","stripLeadingHashOrQuery","responseString","startsWith","substring","getDeserializedResponse","indexOf","normalizedResponse","deserializedHash","Object","fromEntries","URLSearchParams","code","ear_jwe","error","error_description","state","e","createClientAuthError","hashNotDeserialized","mapToQueryString","parameters","encodeExtraParams","extraQueryParameters","queryParameterArray","Array","forEach","value","key","push","encodeURIComponent","join","normalizeUrlForComparison","urlWithoutHash","split","urlObj","URL","normalizedUrl","origin","pathname","search"],"sources":["C:\\_Projects\\DGL_ToDo\\react_todo_dashboard2\\node_modules\\@azure\\msal-common\\src\\utils\\UrlUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthorizeResponse } from \"../response/AuthorizeResponse.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError.js\";\nimport { StringDict } from \"./MsalTypes.js\";\nimport { StringUtils } from \"./StringUtils.js\";\n\n/**\n * Canonicalizes a URL by making it lowercase and ensuring it ends with /\n * Inlined version of UrlString.canonicalizeUri to avoid circular dependency\n * @param url - URL to canonicalize\n * @returns Canonicalized URL\n */\nfunction canonicalizeUrl(url: string): string {\n    if (!url) {\n        return url;\n    }\n\n    let lowerCaseUrl = url.toLowerCase();\n\n    if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n    } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n    }\n\n    if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n    }\n\n    return lowerCaseUrl;\n}\n\n/**\n * Parses hash string from given string. Returns empty string if no hash symbol is found.\n * @param hashString\n */\nexport function stripLeadingHashOrQuery(responseString: string): string {\n    if (responseString.startsWith(\"#/\")) {\n        return responseString.substring(2);\n    } else if (\n        responseString.startsWith(\"#\") ||\n        responseString.startsWith(\"?\")\n    ) {\n        return responseString.substring(1);\n    }\n\n    return responseString;\n}\n\n/**\n * Returns URL hash as server auth code response object.\n */\nexport function getDeserializedResponse(\n    responseString: string\n): AuthorizeResponse | null {\n    // Check if given hash is empty\n    if (!responseString || responseString.indexOf(\"=\") < 0) {\n        return null;\n    }\n    try {\n        // Strip the # or ? symbol if present\n        const normalizedResponse = stripLeadingHashOrQuery(responseString);\n        // If # symbol was not present, above will return empty string, so give original hash value\n        const deserializedHash: AuthorizeResponse = Object.fromEntries(\n            new URLSearchParams(normalizedResponse)\n        );\n\n        // Check for known response properties\n        if (\n            deserializedHash.code ||\n            deserializedHash.ear_jwe ||\n            deserializedHash.error ||\n            deserializedHash.error_description ||\n            deserializedHash.state\n        ) {\n            return deserializedHash;\n        }\n    } catch (e) {\n        throw createClientAuthError(ClientAuthErrorCodes.hashNotDeserialized);\n    }\n\n    return null;\n}\n\n/**\n * Utility to create a URL from the params map\n */\nexport function mapToQueryString(\n    parameters: Map<string, string>,\n    encodeExtraParams: boolean = true,\n    extraQueryParameters?: StringDict\n): string {\n    const queryParameterArray: Array<string> = new Array<string>();\n\n    parameters.forEach((value, key) => {\n        if (\n            !encodeExtraParams &&\n            extraQueryParameters &&\n            key in extraQueryParameters\n        ) {\n            queryParameterArray.push(`${key}=${value}`);\n        } else {\n            queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);\n        }\n    });\n\n    return queryParameterArray.join(\"&\");\n}\n\n/**\n * Normalizes URLs for comparison by removing hash, canonicalizing,\n * and ensuring consistent URL encoding in query parameters.\n * This fixes redirect loops when URLs contain encoded characters like apostrophes (%27).\n * @param url - URL to normalize\n * @returns Normalized URL string for comparison\n */\nexport function normalizeUrlForComparison(url: string): string {\n    if (!url) {\n        return url;\n    }\n\n    // Remove hash first\n    const urlWithoutHash = url.split(\"#\")[0];\n\n    try {\n        // Parse the URL to handle encoding consistently\n        const urlObj = new URL(urlWithoutHash);\n\n        /*\n         * Reconstruct the URL with properly decoded query parameters\n         * This ensures that %27 and ' are treated as equivalent\n         */\n        const normalizedUrl = urlObj.origin + urlObj.pathname + urlObj.search;\n\n        // Apply canonicalization logic inline to avoid circular dependency\n        return canonicalizeUrl(normalizedUrl);\n    } catch (e) {\n        // Fallback to original logic if URL parsing fails\n        return canonicalizeUrl(urlWithoutHash);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}