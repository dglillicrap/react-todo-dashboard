{"ast":null,"code":"/*! @azure/msal-browser v4.24.1 2025-09-30 */\n'use strict';\n\nimport { CacheManager, CacheHelpers, TimeUtils, DEFAULT_TOKEN_RENEWAL_OFFSET_SEC, createCacheError, CacheErrorCodes, invokeAsync, PerformanceEvents, AccountEntity, Constants, PersistentCacheKeys, StringUtils, AuthenticationScheme, CacheError, DEFAULT_CRYPTO_IMPLEMENTATION, CredentialType } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserCacheLocation, InMemoryCacheKeys, TemporaryCacheKeys, INTERACTION_TYPE } from '../utils/BrowserConstants.mjs';\nimport { ACCOUNT_SCHEMA_VERSION, CREDENTIAL_SCHEMA_VERSION, getAccountKeysCacheKey, PREFIX, CACHE_KEY_SEPARATOR, VERSION_CACHE_KEY, getTokenKeysCacheKey } from './CacheKeys.mjs';\nimport { LocalStorage } from './LocalStorage.mjs';\nimport { SessionStorage } from './SessionStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { CookieStorage } from './CookieStorage.mjs';\nimport { getAccountKeys, getTokenKeys } from './CacheHelpers.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { clearHash } from '../utils/BrowserUtils.mjs';\nimport { version } from '../packageMetadata.mjs';\nimport { removeElementFromArray } from '../utils/Helpers.mjs';\nimport { isEncrypted } from './EncryptedData.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\nclass BrowserCacheManager extends CacheManager {\n  constructor(clientId, cacheConfig, cryptoImpl, logger, performanceClient, eventHandler, staticAuthorityOptions) {\n    super(clientId, cryptoImpl, logger, performanceClient, staticAuthorityOptions);\n    this.cacheConfig = cacheConfig;\n    this.logger = logger;\n    this.internalStorage = new MemoryStorage();\n    this.browserStorage = getStorageImplementation(clientId, cacheConfig.cacheLocation, logger, performanceClient);\n    this.temporaryCacheStorage = getStorageImplementation(clientId, cacheConfig.temporaryCacheLocation, logger, performanceClient);\n    this.cookieStorage = new CookieStorage();\n    this.eventHandler = eventHandler;\n  }\n  async initialize(correlationId) {\n    this.performanceClient.addFields({\n      cacheLocation: this.cacheConfig.cacheLocation,\n      cacheRetentionDays: this.cacheConfig.cacheRetentionDays\n    }, correlationId);\n    await this.browserStorage.initialize(correlationId);\n    await this.migrateExistingCache(correlationId);\n    this.trackVersionChanges(correlationId);\n  }\n  /**\r\n   * Migrates any existing cache data from previous versions of MSAL.js into the current cache structure.\r\n   */\n  async migrateExistingCache(correlationId) {\n    const accountKeys0 = getAccountKeys(this.browserStorage, 0);\n    const tokenKeys0 = getTokenKeys(this.clientId, this.browserStorage, 0);\n    this.performanceClient.addFields({\n      oldAccountCount: accountKeys0.length,\n      oldAccessCount: tokenKeys0.accessToken.length,\n      oldIdCount: tokenKeys0.idToken.length,\n      oldRefreshCount: tokenKeys0.refreshToken.length\n    }, correlationId);\n    const accountKeys1 = getAccountKeys(this.browserStorage, 1);\n    const tokenKeys1 = getTokenKeys(this.clientId, this.browserStorage, 1);\n    this.performanceClient.addFields({\n      currAccountCount: accountKeys1.length,\n      currAccessCount: tokenKeys1.accessToken.length,\n      currIdCount: tokenKeys1.idToken.length,\n      currRefreshCount: tokenKeys1.refreshToken.length\n    }, correlationId);\n    await Promise.all([this.updateV0ToCurrent(ACCOUNT_SCHEMA_VERSION, accountKeys0, accountKeys1, correlationId), this.updateV0ToCurrent(CREDENTIAL_SCHEMA_VERSION, tokenKeys0.idToken, tokenKeys1.idToken, correlationId), this.updateV0ToCurrent(CREDENTIAL_SCHEMA_VERSION, tokenKeys0.accessToken, tokenKeys1.accessToken, correlationId), this.updateV0ToCurrent(CREDENTIAL_SCHEMA_VERSION, tokenKeys0.refreshToken, tokenKeys1.refreshToken, correlationId)]);\n    if (accountKeys0.length > 0) {\n      this.browserStorage.setItem(getAccountKeysCacheKey(0), JSON.stringify(accountKeys0));\n    } else {\n      this.browserStorage.removeItem(getAccountKeysCacheKey(0));\n    }\n    if (accountKeys1.length > 0) {\n      this.browserStorage.setItem(getAccountKeysCacheKey(1), JSON.stringify(accountKeys1));\n    } else {\n      this.browserStorage.removeItem(getAccountKeysCacheKey(1));\n    }\n    this.setTokenKeys(tokenKeys0, correlationId, 0);\n    this.setTokenKeys(tokenKeys1, correlationId, 1);\n  }\n  async updateV0ToCurrent(currentSchema, v0Keys, v1Keys, correlationId) {\n    const upgradePromises = [];\n    for (const v0Key of [...v0Keys]) {\n      const rawV0Value = this.browserStorage.getItem(v0Key);\n      const parsedV0Value = this.validateAndParseJson(rawV0Value || \"\");\n      if (!parsedV0Value) {\n        removeElementFromArray(v0Keys, v0Key);\n        continue;\n      }\n      if (!parsedV0Value.lastUpdatedAt) {\n        // Add lastUpdatedAt to the existing v0 entry if it doesnt exist so we know when it's safe to remove it\n        parsedV0Value.lastUpdatedAt = Date.now().toString();\n        this.setItem(v0Key, JSON.stringify(parsedV0Value), correlationId);\n      }\n      const decryptedData = isEncrypted(parsedV0Value) ? await this.browserStorage.decryptData(v0Key, parsedV0Value, correlationId) : parsedV0Value;\n      let expirationTime;\n      if (decryptedData) {\n        if (CacheHelpers.isAccessTokenEntity(decryptedData)) {\n          expirationTime = decryptedData.expiresOn;\n        } else if (CacheHelpers.isRefreshTokenEntity(decryptedData)) {\n          expirationTime = decryptedData.expiresOn;\n        }\n      }\n      if (!decryptedData || TimeUtils.isCacheExpired(parsedV0Value.lastUpdatedAt, this.cacheConfig.cacheRetentionDays) || expirationTime && TimeUtils.isTokenExpired(expirationTime, DEFAULT_TOKEN_RENEWAL_OFFSET_SEC)) {\n        this.browserStorage.removeItem(v0Key);\n        removeElementFromArray(v0Keys, v0Key);\n        this.performanceClient.incrementFields({\n          expiredCacheRemovedCount: 1\n        }, correlationId);\n        continue;\n      }\n      if (this.cacheConfig.cacheLocation !== BrowserCacheLocation.LocalStorage || isEncrypted(parsedV0Value)) {\n        const v1Key = \"\".concat(PREFIX, \".\").concat(currentSchema).concat(CACHE_KEY_SEPARATOR).concat(v0Key);\n        const rawV1Entry = this.browserStorage.getItem(v1Key);\n        if (!rawV1Entry) {\n          upgradePromises.push(this.setUserData(v1Key, JSON.stringify(decryptedData), correlationId, parsedV0Value.lastUpdatedAt).then(() => {\n            v1Keys.push(v1Key);\n            this.performanceClient.incrementFields({\n              upgradedCacheCount: 1\n            }, correlationId);\n          }));\n          continue;\n        } else {\n          const parsedV1Entry = this.validateAndParseJson(rawV1Entry);\n          // If the entry already exists but is older than the v0 entry, replace it\n          if (Number(parsedV0Value.lastUpdatedAt) > Number(parsedV1Entry.lastUpdatedAt)) {\n            upgradePromises.push(this.setUserData(v1Key, JSON.stringify(decryptedData), correlationId, parsedV0Value.lastUpdatedAt).then(() => {\n              this.performanceClient.incrementFields({\n                updatedCacheFromV0Count: 1\n              }, correlationId);\n            }));\n            continue;\n          }\n        }\n      }\n      /*\r\n       * Note: If we reach here for unencrypted localStorage data, we continue without migrating\r\n       * as we can't migrate unencrypted localStorage data right now since we can't guarantee KMSI=no\r\n       */\n    }\n    return Promise.all(upgradePromises);\n  }\n  /**\r\n   * Tracks upgrades and downgrades for telemetry and debugging purposes\r\n   */\n  trackVersionChanges(correlationId) {\n    const previousVersion = this.browserStorage.getItem(VERSION_CACHE_KEY);\n    if (previousVersion) {\n      this.logger.info(\"MSAL.js was last initialized by version: \".concat(previousVersion));\n      this.performanceClient.addFields({\n        previousLibraryVersion: previousVersion\n      }, correlationId);\n    }\n    if (previousVersion !== version) {\n      this.setItem(VERSION_CACHE_KEY, version, correlationId);\n    }\n  }\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n  validateAndParseJson(jsonValue) {\n    if (!jsonValue) {\n      return null;\n    }\n    try {\n      const parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\r\n   * Helper to setItem in browser storage, with cleanup in case of quota errors\r\n   * @param key\r\n   * @param value\r\n   */\n  setItem(key, value, correlationId) {\n    let tokenKeysV0Count = 0;\n    let accessTokenKeys = [];\n    const maxRetries = 20;\n    for (let i = 0; i <= maxRetries; i++) {\n      try {\n        this.browserStorage.setItem(key, value);\n        if (i > 0) {\n          // Finally update the token keys array with the tokens removed\n          if (i <= tokenKeysV0Count) {\n            this.removeAccessTokenKeys(accessTokenKeys.slice(0, i), correlationId, 0);\n          } else {\n            this.removeAccessTokenKeys(accessTokenKeys.slice(0, tokenKeysV0Count), correlationId, 0);\n            this.removeAccessTokenKeys(accessTokenKeys.slice(tokenKeysV0Count, i), correlationId);\n          }\n        }\n        break; // If setItem succeeds, exit the loop\n      } catch (e) {\n        const cacheError = createCacheError(e);\n        if (cacheError.errorCode === CacheErrorCodes.cacheQuotaExceeded && i < maxRetries) {\n          if (!accessTokenKeys.length) {\n            // If we are currently trying to set the token keys, use the value we're trying to set\n            const tokenKeys0 = key === getTokenKeysCacheKey(this.clientId, 0) ? JSON.parse(value).accessToken : this.getTokenKeys(0).accessToken;\n            const tokenKeys1 = key === getTokenKeysCacheKey(this.clientId) ? JSON.parse(value).accessToken : this.getTokenKeys().accessToken;\n            accessTokenKeys = [...tokenKeys0, ...tokenKeys1];\n            tokenKeysV0Count = tokenKeys0.length;\n          }\n          if (accessTokenKeys.length <= i) {\n            // Nothing to remove, rethrow the error\n            throw cacheError;\n          }\n          // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n          this.removeAccessToken(accessTokenKeys[i], correlationId, false // Don't save token keys yet, do it at the end\n          );\n        } else {\n          // If the error is not a quota exceeded error, rethrow it\n          throw cacheError;\n        }\n      }\n    }\n  }\n  /**\r\n   * Helper to setUserData in browser storage, with cleanup in case of quota errors\r\n   * @param key\r\n   * @param value\r\n   * @param correlationId\r\n   */\n  async setUserData(key, value, correlationId, timestamp) {\n    let tokenKeysV0Count = 0;\n    let accessTokenKeys = [];\n    const maxRetries = 20;\n    for (let i = 0; i <= maxRetries; i++) {\n      try {\n        await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(key, value, correlationId, timestamp);\n        if (i > 0) {\n          // Finally update the token keys array with the tokens removed\n          if (i <= tokenKeysV0Count) {\n            this.removeAccessTokenKeys(accessTokenKeys.slice(0, i), correlationId, 0);\n          } else {\n            this.removeAccessTokenKeys(accessTokenKeys.slice(0, tokenKeysV0Count), correlationId, 0);\n            this.removeAccessTokenKeys(accessTokenKeys.slice(tokenKeysV0Count, i), correlationId);\n          }\n        }\n        break; // If setItem succeeds, exit the loop\n      } catch (e) {\n        const cacheError = createCacheError(e);\n        if (cacheError.errorCode === CacheErrorCodes.cacheQuotaExceeded && i < maxRetries) {\n          if (!accessTokenKeys.length) {\n            const tokenKeys0 = this.getTokenKeys(0).accessToken;\n            const tokenKeys1 = this.getTokenKeys().accessToken;\n            accessTokenKeys = [...tokenKeys0, ...tokenKeys1];\n            tokenKeysV0Count = tokenKeys0.length;\n          }\n          if (accessTokenKeys.length <= i) {\n            // Nothing left to remove, rethrow the error\n            throw cacheError;\n          }\n          // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n          this.removeAccessToken(accessTokenKeys[i], correlationId, false // Don't save token keys yet, do it at the end\n          );\n        } else {\n          // If the error is not a quota exceeded error, rethrow it\n          throw cacheError;\n        }\n      }\n    }\n  }\n  /**\r\n   * Reads account from cache, deserializes it into an account entity and returns it.\r\n   * If account is not found from the key, returns null and removes key from map.\r\n   * @param accountKey\r\n   * @returns\r\n   */\n  getAccount(accountKey, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    const serializedAccount = this.browserStorage.getUserData(accountKey);\n    if (!serializedAccount) {\n      this.removeAccountKeyFromMap(accountKey, correlationId);\n      return null;\n    }\n    const parsedAccount = this.validateAndParseJson(serializedAccount);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  }\n  /**\r\n   * set account entity in the platform cache\r\n   * @param account\r\n   */\n  async setAccount(account, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    const key = this.generateAccountKey(account.getAccountInfo());\n    const timestamp = Date.now().toString();\n    account.lastUpdatedAt = timestamp;\n    await this.setUserData(key, JSON.stringify(account), correlationId, timestamp);\n    const wasAdded = this.addAccountKeyToMap(key, correlationId);\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage && wasAdded) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_ADDED, undefined, account.getAccountInfo());\n    }\n  }\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n  getAccountKeys() {\n    return getAccountKeys(this.browserStorage);\n  }\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n  addAccountKeyToMap(key, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.addAccountKeyToMap called with key: \".concat(key));\n    const accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(getAccountKeysCacheKey(), JSON.stringify(accountKeys), correlationId);\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n      return true;\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n      return false;\n    }\n  }\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n  removeAccountKeyFromMap(key, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.removeAccountKeyFromMap called with key: \".concat(key));\n    const accountKeys = this.getAccountKeys();\n    const removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      if (accountKeys.length === 0) {\n        // If no keys left, remove the map\n        this.removeItem(getAccountKeysCacheKey());\n        return;\n      } else {\n        this.setItem(getAccountKeysCacheKey(), JSON.stringify(accountKeys), correlationId);\n      }\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  }\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n  removeAccount(account, correlationId) {\n    const activeAccount = this.getActiveAccount(correlationId);\n    if ((activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.homeAccountId) === account.homeAccountId && (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.environment) === account.environment) {\n      this.setActiveAccount(null, correlationId);\n    }\n    super.removeAccount(account, correlationId);\n    this.removeAccountKeyFromMap(this.generateAccountKey(account), correlationId);\n    // Remove all other associated cache items\n    this.browserStorage.getKeys().forEach(key => {\n      if (key.includes(account.homeAccountId) && key.includes(account.environment)) {\n        this.browserStorage.removeItem(key);\n      }\n    });\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_REMOVED, undefined, account);\n    }\n  }\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeIdToken(key, correlationId) {\n    super.removeIdToken(key, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    const idRemoval = tokenKeys.idToken.indexOf(key);\n    if (idRemoval > -1) {\n      this.logger.info(\"idToken removed from tokenKeys map\");\n      tokenKeys.idToken.splice(idRemoval, 1);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeAccessToken(key, correlationId) {\n    let updateTokenKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    super.removeAccessToken(key, correlationId);\n    updateTokenKeys && this.removeAccessTokenKeys([key], correlationId);\n  }\n  /**\r\n   * Remove access token key from the key map\r\n   * @param key\r\n   * @param correlationId\r\n   * @param tokenKeys\r\n   */\n  removeAccessTokenKeys(keys, correlationId) {\n    let schemaVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CREDENTIAL_SCHEMA_VERSION;\n    this.logger.trace(\"removeAccessTokenKey called\");\n    const tokenKeys = this.getTokenKeys(schemaVersion);\n    let keysRemoved = 0;\n    keys.forEach(key => {\n      const accessRemoval = tokenKeys.accessToken.indexOf(key);\n      if (accessRemoval > -1) {\n        tokenKeys.accessToken.splice(accessRemoval, 1);\n        keysRemoved++;\n      }\n    });\n    if (keysRemoved > 0) {\n      this.logger.info(\"removed \".concat(keysRemoved, \" accessToken keys from tokenKeys map\"));\n      this.setTokenKeys(tokenKeys, correlationId, schemaVersion);\n      return;\n    }\n  }\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeRefreshToken(key, correlationId) {\n    super.removeRefreshToken(key, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n    if (refreshRemoval > -1) {\n      this.logger.info(\"refreshToken removed from tokenKeys map\");\n      tokenKeys.refreshToken.splice(refreshRemoval, 1);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n  getTokenKeys() {\n    let schemaVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CREDENTIAL_SCHEMA_VERSION;\n    return getTokenKeys(this.clientId, this.browserStorage, schemaVersion);\n  }\n  /**\r\n   * Stores the token keys in the cache\r\n   * @param tokenKeys\r\n   * @param correlationId\r\n   * @returns\r\n   */\n  setTokenKeys(tokenKeys, correlationId) {\n    let schemaVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CREDENTIAL_SCHEMA_VERSION;\n    if (tokenKeys.idToken.length === 0 && tokenKeys.accessToken.length === 0 && tokenKeys.refreshToken.length === 0) {\n      // If no keys left, remove the map\n      this.removeItem(getTokenKeysCacheKey(this.clientId, schemaVersion));\n      return;\n    } else {\n      this.setItem(getTokenKeysCacheKey(this.clientId, schemaVersion), JSON.stringify(tokenKeys), correlationId);\n    }\n  }\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n  getIdTokenCredential(idTokenKey, correlationId) {\n    const value = this.browserStorage.getUserData(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeIdToken(idTokenKey, correlationId);\n      return null;\n    }\n    const parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return parsedIdToken;\n  }\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n  async setIdTokenCredential(idToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    const idTokenKey = this.generateCredentialKey(idToken);\n    const timestamp = Date.now().toString();\n    idToken.lastUpdatedAt = timestamp;\n    await this.setUserData(idTokenKey, JSON.stringify(idToken), correlationId, timestamp);\n    const tokenKeys = this.getTokenKeys();\n    if (tokenKeys.idToken.indexOf(idTokenKey) === -1) {\n      this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n      tokenKeys.idToken.push(idTokenKey);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n  getAccessTokenCredential(accessTokenKey, correlationId) {\n    const value = this.browserStorage.getUserData(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeAccessTokenKeys([accessTokenKey], correlationId);\n      return null;\n    }\n    const parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !CacheHelpers.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return parsedAccessToken;\n  }\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n  async setAccessTokenCredential(accessToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    const accessTokenKey = this.generateCredentialKey(accessToken);\n    const timestamp = Date.now().toString();\n    accessToken.lastUpdatedAt = timestamp;\n    await this.setUserData(accessTokenKey, JSON.stringify(accessToken), correlationId, timestamp);\n    const tokenKeys = this.getTokenKeys();\n    const index = tokenKeys.accessToken.indexOf(accessTokenKey);\n    if (index !== -1) {\n      tokenKeys.accessToken.splice(index, 1); // Remove existing key before pushing to the end\n    }\n    this.logger.trace(\"access token \".concat(index === -1 ? \"added to\" : \"updated in\", \" map\"));\n    tokenKeys.accessToken.push(accessTokenKey);\n    this.setTokenKeys(tokenKeys, correlationId);\n  }\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n  getRefreshTokenCredential(refreshTokenKey, correlationId) {\n    const value = this.browserStorage.getUserData(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeRefreshToken(refreshTokenKey, correlationId);\n      return null;\n    }\n    const parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return parsedRefreshToken;\n  }\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n  async setRefreshTokenCredential(refreshToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    const refreshTokenKey = this.generateCredentialKey(refreshToken);\n    const timestamp = Date.now().toString();\n    refreshToken.lastUpdatedAt = timestamp;\n    await this.setUserData(refreshTokenKey, JSON.stringify(refreshToken), correlationId, timestamp);\n    const tokenKeys = this.getTokenKeys();\n    if (tokenKeys.refreshToken.indexOf(refreshTokenKey) === -1) {\n      this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n      tokenKeys.refreshToken.push(refreshTokenKey);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n  getAppMetadata(appMetadataKey) {\n    const value = this.browserStorage.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return parsedMetadata;\n  }\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n  setAppMetadata(appMetadata, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata), correlationId);\n  }\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n  getServerTelemetry(serverTelemetryKey) {\n    const value = this.browserStorage.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    const parsedEntity = this.validateAndParseJson(value);\n    if (!parsedEntity || !CacheHelpers.isServerTelemetryEntity(serverTelemetryKey, parsedEntity)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return parsedEntity;\n  }\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n  setServerTelemetry(serverTelemetryKey, serverTelemetry, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry), correlationId);\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadata(key) {\n    const value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return parsedMetadata;\n    }\n    return null;\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadataKeys() {\n    const allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(key => {\n      return this.isAuthorityMetadata(key);\n    });\n  }\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n  setWrapperMetadata(wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  }\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n  getWrapperMetadata() {\n    const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  }\n  /**\r\n   *\r\n   * @param entity\r\n   */\n  setAuthorityMetadata(key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  }\n  /**\r\n   * Gets the active account\r\n   */\n  getActiveAccount(correlationId) {\n    const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountValueFilters = this.browserStorage.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters found\");\n      return null;\n    }\n    const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoFilteredBy({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId,\n        tenantId: activeAccountValueObj.tenantId\n      }, correlationId);\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  }\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n  setActiveAccount(account, correlationId) {\n    const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      const activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId,\n        tenantId: account.tenantId,\n        lastUpdatedAt: TimeUtils.nowSeconds().toString()\n      };\n      this.setItem(activeAccountKey, JSON.stringify(activeAccountValue), correlationId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n    }\n    this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\n  }\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n  getThrottlingCache(throttlingCacheKey) {\n    const value = this.browserStorage.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    const parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !CacheHelpers.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return parsedThrottlingCache;\n  }\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n  setThrottlingCache(throttlingCacheKey, throttlingCache, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache), correlationId);\n  }\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  getTemporaryCache(cacheKey, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      const itemCookie = this.cookieStorage.getItem(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    const value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        const item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  }\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n  setTemporaryCache(cacheKey, value, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.cookieStorage.setItem(key, value, undefined, this.cacheConfig.secureCookies);\n    }\n  }\n  /**\r\n   * Removes the cache item with the given key.\r\n   * @param key\r\n   */\n  removeItem(key) {\n    this.browserStorage.removeItem(key);\n  }\n  /**\r\n   * Removes the temporary cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  removeTemporaryItem(key) {\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.cookieStorage.removeItem(key);\n    }\n  }\n  /**\r\n   * Gets all keys in window.\r\n   */\n  getKeys() {\n    return this.browserStorage.getKeys();\n  }\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n  clear(correlationId) {\n    // Removes all accounts and their credentials\n    this.removeAllAccounts(correlationId);\n    this.removeAppMetadata(correlationId);\n    // Remove temp storage first to make sure any cookies are cleared\n    this.temporaryCacheStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeTemporaryItem(cacheKey);\n      }\n    });\n    // Removes all remaining MSAL cache items\n    this.browserStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.browserStorage.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  }\n  /**\r\n   * Clears all access tokes that have claims prior to saving the current one\r\n   * @param performanceClient {IPerformanceClient}\r\n   * @param correlationId {string} correlation id\r\n   * @returns\r\n   */\n  clearTokensAndKeysWithClaims(correlationId) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    let removedAccessTokens = 0;\n    tokenKeys.accessToken.forEach(key => {\n      // if the access token has claims in its key, remove the token key and the token\n      const credential = this.getAccessTokenCredential(key, correlationId);\n      if (credential !== null && credential !== void 0 && credential.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n        this.removeAccessToken(key, correlationId);\n        removedAccessTokens++;\n      }\n    });\n    // warn if any access tokens are removed\n    if (removedAccessTokens > 0) {\n      this.logger.warning(\"\".concat(removedAccessTokens, \" access tokens with claims in the cache keys have been removed from the cache.\"));\n    }\n  }\n  /**\r\n   * Prepend msal.<client-id> to each key\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n  generateCacheKey(key) {\n    if (StringUtils.startsWith(key, PREFIX)) {\n      return key;\n    }\n    return \"\".concat(PREFIX, \".\").concat(this.clientId, \".\").concat(key);\n  }\n  /**\r\n   * Cache Key: msal.<schema_version>-<home_account_id>-<environment>-<credential_type>-<client_id or familyId>-<realm>-<scopes>-<claims hash>-<scheme>\r\n   * IdToken Example: uid.utid-login.microsoftonline.com-idtoken-app_client_id-contoso.com\r\n   * AccessToken Example: uid.utid-login.microsoftonline.com-accesstoken-app_client_id-contoso.com-scope1 scope2--pop\r\n   * RefreshToken Example: uid.utid-login.microsoftonline.com-refreshtoken-1-contoso.com\r\n   * @param credentialEntity\r\n   * @returns\r\n   */\n  generateCredentialKey(credential) {\n    const familyId = credential.credentialType === CredentialType.REFRESH_TOKEN && credential.familyId || credential.clientId;\n    const scheme = credential.tokenType && credential.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credential.tokenType.toLowerCase() : \"\";\n    const credentialKey = [\"\".concat(PREFIX, \".\").concat(CREDENTIAL_SCHEMA_VERSION), credential.homeAccountId, credential.environment, credential.credentialType, familyId, credential.realm || \"\", credential.target || \"\", credential.requestedClaimsHash || \"\", scheme];\n    return credentialKey.join(CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\r\n   * Cache Key: msal.<schema_version>.<home_account_id>.<environment>.<tenant_id>\r\n   * @param account\r\n   * @returns\r\n   */\n  generateAccountKey(account) {\n    const homeTenantId = account.homeAccountId.split(\".\")[1];\n    const accountKey = [\"\".concat(PREFIX, \".\").concat(ACCOUNT_SCHEMA_VERSION), account.homeAccountId, account.environment, homeTenantId || account.tenantId || \"\"];\n    return accountKey.join(CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n  resetRequestCache() {\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.VERIFIER));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  }\n  cacheAuthorizeRequest(authCodeRequest, codeVerifier) {\n    this.logger.trace(\"BrowserCacheManager.cacheAuthorizeRequest called\");\n    const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n    if (codeVerifier) {\n      const encodedVerifier = base64Encode(codeVerifier);\n      this.setTemporaryCache(TemporaryCacheKeys.VERIFIER, encodedVerifier, true);\n    }\n  }\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n  getCachedRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw createBrowserAuthError(noTokenRequestCacheError);\n    }\n    const encodedVerifier = this.getTemporaryCache(TemporaryCacheKeys.VERIFIER, true);\n    let parsedRequest;\n    let verifier = \"\";\n    try {\n      parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n      if (encodedVerifier) {\n        verifier = base64Decode(encodedVerifier);\n      }\n    } catch (e) {\n      this.logger.errorPii(\"Attempted to parse: \".concat(encodedTokenRequest));\n      this.logger.error(\"Parsing cached token request threw with error: \".concat(e));\n      throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n    }\n    return [parsedRequest, verifier];\n  }\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n  getCachedNativeRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    const parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  }\n  isInteractionInProgress(matchClientId) {\n    var _this$getInteractionI;\n    const clientId = (_this$getInteractionI = this.getInteractionInProgress()) === null || _this$getInteractionI === void 0 ? void 0 : _this$getInteractionI.clientId;\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  }\n  getInteractionInProgress() {\n    const key = \"\".concat(PREFIX, \".\").concat(TemporaryCacheKeys.INTERACTION_STATUS_KEY);\n    const value = this.getTemporaryCache(key, false);\n    try {\n      return value ? JSON.parse(value) : null;\n    } catch (e) {\n      // Remove interaction and other temp keys if interaction status can't be parsed\n      this.logger.error(\"Cannot parse interaction status. Removing temporary cache items and clearing url hash. Retrying interaction should fix the error\");\n      this.removeTemporaryItem(key);\n      this.resetRequestCache();\n      clearHash(window);\n      return null;\n    }\n  }\n  setInteractionInProgress(inProgress) {\n    var _this$getInteractionI2;\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INTERACTION_TYPE.SIGNIN;\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    const key = \"\".concat(PREFIX, \".\").concat(TemporaryCacheKeys.INTERACTION_STATUS_KEY);\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw createBrowserAuthError(interactionInProgress);\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, JSON.stringify({\n          clientId: this.clientId,\n          type\n        }), false);\n      }\n    } else if (!inProgress && ((_this$getInteractionI2 = this.getInteractionInProgress()) === null || _this$getInteractionI2 === void 0 ? void 0 : _this$getInteractionI2.clientId) === this.clientId) {\n      this.removeTemporaryItem(key);\n    }\n  }\n  /**\r\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n   * @param result\r\n   * @param request\r\n   */\n  async hydrateCache(result, request) {\n    var _result$account, _result$account2, _result$account3;\n    const idTokenEntity = CacheHelpers.createIdTokenEntity((_result$account = result.account) === null || _result$account === void 0 ? void 0 : _result$account.homeAccountId, (_result$account2 = result.account) === null || _result$account2 === void 0 ? void 0 : _result$account2.environment, result.idToken, this.clientId, result.tenantId);\n    let claimsHash;\n    if (request.claims) {\n      claimsHash = await this.cryptoImpl.hashString(request.claims);\n    }\n    /**\r\n     * meta data for cache stores time in seconds from epoch\r\n     * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\r\n     * We need to map these for the cache when building tokens from AuthenticationResult\r\n     *\r\n     * The next MSAL VFuture should map these both to same value if possible\r\n     */\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity((_result$account3 = result.account) === null || _result$account3 === void 0 ? void 0 : _result$account3.homeAccountId, result.account.environment, result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"),\n    // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date\n    result.expiresOn ? TimeUtils.toSecondsFromDate(result.expiresOn) : 0, result.extExpiresOn ? TimeUtils.toSecondsFromDate(result.extExpiresOn) : 0, base64Decode, undefined,\n    // refreshOn\n    result.tokenType, undefined,\n    // userAssertionHash\n    request.sshKid, request.claims, claimsHash);\n    const cacheRecord = {\n      idToken: idTokenEntity,\n      accessToken: accessTokenEntity\n    };\n    return this.saveCacheRecord(cacheRecord, result.correlationId);\n  }\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord {CacheRecord}\r\n   * @param storeInCache {?StoreInCache}\r\n   * @param correlationId {?string} correlation id\r\n   */\n  async saveCacheRecord(cacheRecord, correlationId, storeInCache) {\n    try {\n      await super.saveCacheRecord(cacheRecord, correlationId, storeInCache);\n    } catch (e) {\n      if (e instanceof CacheError && this.performanceClient && correlationId) {\n        try {\n          const tokenKeys = this.getTokenKeys();\n          this.performanceClient.addFields({\n            cacheRtCount: tokenKeys.refreshToken.length,\n            cacheIdCount: tokenKeys.idToken.length,\n            cacheAtCount: tokenKeys.accessToken.length\n          }, correlationId);\n        } catch (e) {}\n      }\n      throw e;\n    }\n  }\n}\n/**\r\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n * @param cacheLocation\r\n */\nfunction getStorageImplementation(clientId, cacheLocation, logger, performanceClient) {\n  try {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n        return new LocalStorage(clientId, logger, performanceClient);\n      case BrowserCacheLocation.SessionStorage:\n        return new SessionStorage();\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        break;\n    }\n  } catch (e) {\n    logger.error(e);\n  }\n  return new MemoryStorage();\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger, performanceClient, eventHandler) => {\n  const cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    cacheRetentionDays: 5,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger, performanceClient, eventHandler);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["BrowserCacheManager","CacheManager","constructor","clientId","cacheConfig","cryptoImpl","logger","performanceClient","eventHandler","staticAuthorityOptions","internalStorage","MemoryStorage","browserStorage","getStorageImplementation","cacheLocation","temporaryCacheStorage","temporaryCacheLocation","cookieStorage","CookieStorage","initialize","correlationId","addFields","cacheRetentionDays","migrateExistingCache","trackVersionChanges","accountKeys0","getAccountKeys","tokenKeys0","getTokenKeys","oldAccountCount","length","oldAccessCount","accessToken","oldIdCount","idToken","oldRefreshCount","refreshToken","accountKeys1","tokenKeys1","currAccountCount","currAccessCount","currIdCount","currRefreshCount","Promise","all","updateV0ToCurrent","ACCOUNT_SCHEMA_VERSION","CREDENTIAL_SCHEMA_VERSION","setItem","getAccountKeysCacheKey","JSON","stringify","removeItem","setTokenKeys","currentSchema","v0Keys","v1Keys","upgradePromises","v0Key","rawV0Value","getItem","parsedV0Value","validateAndParseJson","removeElementFromArray","lastUpdatedAt","Date","now","toString","decryptedData","isEncrypted","decryptData","expirationTime","CacheHelpers","isAccessTokenEntity","expiresOn","isRefreshTokenEntity","TimeUtils","isCacheExpired","isTokenExpired","DEFAULT_TOKEN_RENEWAL_OFFSET_SEC","incrementFields","expiredCacheRemovedCount","BrowserCacheLocation","LocalStorage","v1Key","concat","PREFIX","CACHE_KEY_SEPARATOR","rawV1Entry","push","setUserData","then","upgradedCacheCount","parsedV1Entry","Number","updatedCacheFromV0Count","previousVersion","VERSION_CACHE_KEY","info","previousLibraryVersion","version","jsonValue","parsedJson","parse","error","key","value","tokenKeysV0Count","accessTokenKeys","maxRetries","i","removeAccessTokenKeys","slice","e","cacheError","createCacheError","errorCode","CacheErrorCodes","cacheQuotaExceeded","getTokenKeysCacheKey","removeAccessToken","timestamp","invokeAsync","bind","PerformanceEvents","SetUserData","getAccount","accountKey","trace","serializedAccount","getUserData","removeAccountKeyFromMap","parsedAccount","AccountEntity","isAccountEntity","toObject","setAccount","account","generateAccountKey","getAccountInfo","wasAdded","addAccountKeyToMap","emitEvent","EventType","ACCOUNT_ADDED","undefined","tracePii","accountKeys","indexOf","verbose","removalIndex","splice","removeAccount","activeAccount","getActiveAccount","homeAccountId","environment","setActiveAccount","getKeys","forEach","includes","ACCOUNT_REMOVED","removeIdToken","tokenKeys","idRemoval","updateTokenKeys","arguments","keys","schemaVersion","keysRemoved","accessRemoval","removeRefreshToken","refreshRemoval","getIdTokenCredential","idTokenKey","parsedIdToken","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","setAccessTokenCredential","index","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","setRefreshTokenCredential","getAppMetadata","appMetadataKey","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","parsedEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","allKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","InMemoryCacheKeys","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","Constants","EMPTY_STRING","setAuthorityMetadata","entity","activeAccountKeyFilters","generateCacheKey","PersistentCacheKeys","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountValueObj","getAccountInfoFilteredBy","localAccountId","tenantId","activeAccountKey","activeAccountValue","nowSeconds","ACTIVE_ACCOUNT_CHANGED","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","cacheKey","generateKey","storeAuthStateInCookie","itemCookie","item","setTemporaryCache","secureCookies","removeTemporaryItem","clear","removeAllAccounts","removeAppMetadata","clearTokensAndKeysWithClaims","addQueueMeasurement","ClearTokensAndKeysWithClaims","removedAccessTokens","credential","requestedClaimsHash","toLowerCase","warning","StringUtils","startsWith","familyId","credentialType","CredentialType","REFRESH_TOKEN","scheme","tokenType","AuthenticationScheme","BEARER","credentialKey","realm","target","join","homeTenantId","split","resetRequestCache","TemporaryCacheKeys","REQUEST_PARAMS","VERIFIER","ORIGIN_URI","URL_HASH","NATIVE_REQUEST","setInteractionInProgress","cacheAuthorizeRequest","authCodeRequest","codeVerifier","encodedValue","base64Encode","encodedVerifier","getCachedRequest","encodedTokenRequest","createBrowserAuthError","noTokenRequestCacheError","parsedRequest","verifier","base64Decode","errorPii","unableToParseTokenRequestCacheError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","_this$getInteractionI","getInteractionInProgress","INTERACTION_STATUS_KEY","clearHash","window","inProgress","_this$getInteractionI2","type","INTERACTION_TYPE","SIGNIN","interactionInProgress","hydrateCache","result","request","_result$account","_result$account2","_result$account3","idTokenEntity","createIdTokenEntity","claimsHash","claims","hashString","accessTokenEntity","createAccessTokenEntity","scopes","toSecondsFromDate","extExpiresOn","sshKid","cacheRecord","saveCacheRecord","storeInCache","CacheError","cacheRtCount","cacheIdCount","cacheAtCount","SessionStorage","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","cacheMigrationEnabled","claimsBasedCachingEnabled","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["C:\\_Projects\\DGL_ToDo\\react_todo_dashboard2\\node_modules\\@azure\\msal-browser\\src\\cache\\BrowserCacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccessTokenEntity,\n    AccountEntity,\n    AccountInfo,\n    ActiveAccountFilters,\n    AppMetadataEntity,\n    AuthenticationScheme,\n    AuthorityMetadataEntity,\n    CacheError,\n    CacheErrorCodes,\n    CacheHelpers,\n    CacheManager,\n    CacheRecord,\n    CommonAuthorizationUrlRequest,\n    Constants,\n    createCacheError,\n    DEFAULT_CRYPTO_IMPLEMENTATION,\n    ICrypto,\n    IdTokenEntity,\n    invokeAsync,\n    IPerformanceClient,\n    Logger,\n    PerformanceEvents,\n    PersistentCacheKeys,\n    RefreshTokenEntity,\n    ServerTelemetryEntity,\n    StaticAuthorityOptions,\n    StoreInCache,\n    StringUtils,\n    ThrottlingEntity,\n    TimeUtils,\n    TokenKeys,\n    CredentialEntity,\n    CredentialType,\n    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,\n} from \"@azure/msal-common/browser\";\nimport { CacheOptions } from \"../config/Configuration.js\";\nimport {\n    BrowserAuthErrorCodes,\n    createBrowserAuthError,\n} from \"../error/BrowserAuthError.js\";\nimport {\n    BrowserCacheLocation,\n    InMemoryCacheKeys,\n    INTERACTION_TYPE,\n    TemporaryCacheKeys,\n} from \"../utils/BrowserConstants.js\";\nimport * as CacheKeys from \"./CacheKeys.js\";\nimport { LocalStorage } from \"./LocalStorage.js\";\nimport { SessionStorage } from \"./SessionStorage.js\";\nimport { MemoryStorage } from \"./MemoryStorage.js\";\nimport { IWindowStorage } from \"./IWindowStorage.js\";\nimport { PlatformAuthRequest } from \"../broker/nativeBroker/PlatformAuthRequest.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { SilentRequest } from \"../request/SilentRequest.js\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest.js\";\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\nimport { PopupRequest } from \"../request/PopupRequest.js\";\nimport { base64Decode } from \"../encode/Base64Decode.js\";\nimport { base64Encode } from \"../encode/Base64Encode.js\";\nimport { CookieStorage } from \"./CookieStorage.js\";\nimport { getAccountKeys, getTokenKeys } from \"./CacheHelpers.js\";\nimport { EventType } from \"../event/EventType.js\";\nimport { EventHandler } from \"../event/EventHandler.js\";\nimport { clearHash } from \"../utils/BrowserUtils.js\";\nimport { version } from \"../packageMetadata.js\";\nimport { removeElementFromArray } from \"../utils/Helpers.js\";\nimport { EncryptedData, isEncrypted } from \"./EncryptedData.js\";\n\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nexport class BrowserCacheManager extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    protected cacheConfig: Required<CacheOptions>;\n    // Window storage object (either local or sessionStorage)\n    protected browserStorage: IWindowStorage<string>;\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\n    protected internalStorage: MemoryStorage<string>;\n    // Temporary cache\n    protected temporaryCacheStorage: IWindowStorage<string>;\n    // Cookie storage\n    protected cookieStorage: CookieStorage;\n    // Logger instance\n    protected logger: Logger;\n    // Event Handler\n    private eventHandler: EventHandler;\n\n    constructor(\n        clientId: string,\n        cacheConfig: Required<CacheOptions>,\n        cryptoImpl: ICrypto,\n        logger: Logger,\n        performanceClient: IPerformanceClient,\n        eventHandler: EventHandler,\n        staticAuthorityOptions?: StaticAuthorityOptions\n    ) {\n        super(\n            clientId,\n            cryptoImpl,\n            logger,\n            performanceClient,\n            staticAuthorityOptions\n        );\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = getStorageImplementation(\n            clientId,\n            cacheConfig.cacheLocation,\n            logger,\n            performanceClient\n        );\n        this.temporaryCacheStorage = getStorageImplementation(\n            clientId,\n            cacheConfig.temporaryCacheLocation,\n            logger,\n            performanceClient\n        );\n        this.cookieStorage = new CookieStorage();\n        this.eventHandler = eventHandler;\n    }\n\n    async initialize(correlationId: string): Promise<void> {\n        this.performanceClient.addFields(\n            {\n                cacheLocation: this.cacheConfig.cacheLocation,\n                cacheRetentionDays: this.cacheConfig.cacheRetentionDays,\n            },\n            correlationId\n        );\n        await this.browserStorage.initialize(correlationId);\n        await this.migrateExistingCache(correlationId);\n        this.trackVersionChanges(correlationId);\n    }\n\n    /**\n     * Migrates any existing cache data from previous versions of MSAL.js into the current cache structure.\n     */\n    async migrateExistingCache(correlationId: string): Promise<void> {\n        const accountKeys0 = getAccountKeys(this.browserStorage, 0);\n        const tokenKeys0 = getTokenKeys(this.clientId, this.browserStorage, 0);\n        this.performanceClient.addFields(\n            {\n                oldAccountCount: accountKeys0.length,\n                oldAccessCount: tokenKeys0.accessToken.length,\n                oldIdCount: tokenKeys0.idToken.length,\n                oldRefreshCount: tokenKeys0.refreshToken.length,\n            },\n            correlationId\n        );\n\n        const accountKeys1 = getAccountKeys(this.browserStorage, 1);\n        const tokenKeys1 = getTokenKeys(this.clientId, this.browserStorage, 1);\n        this.performanceClient.addFields(\n            {\n                currAccountCount: accountKeys1.length,\n                currAccessCount: tokenKeys1.accessToken.length,\n                currIdCount: tokenKeys1.idToken.length,\n                currRefreshCount: tokenKeys1.refreshToken.length,\n            },\n            correlationId\n        );\n\n        await Promise.all([\n            this.updateV0ToCurrent(\n                CacheKeys.ACCOUNT_SCHEMA_VERSION,\n                accountKeys0,\n                accountKeys1,\n                correlationId\n            ),\n            this.updateV0ToCurrent(\n                CacheKeys.CREDENTIAL_SCHEMA_VERSION,\n                tokenKeys0.idToken,\n                tokenKeys1.idToken,\n                correlationId\n            ),\n            this.updateV0ToCurrent(\n                CacheKeys.CREDENTIAL_SCHEMA_VERSION,\n                tokenKeys0.accessToken,\n                tokenKeys1.accessToken,\n                correlationId\n            ),\n            this.updateV0ToCurrent(\n                CacheKeys.CREDENTIAL_SCHEMA_VERSION,\n                tokenKeys0.refreshToken,\n                tokenKeys1.refreshToken,\n                correlationId\n            ),\n        ]);\n\n        if (accountKeys0.length > 0) {\n            this.browserStorage.setItem(\n                CacheKeys.getAccountKeysCacheKey(0),\n                JSON.stringify(accountKeys0)\n            );\n        } else {\n            this.browserStorage.removeItem(CacheKeys.getAccountKeysCacheKey(0));\n        }\n\n        if (accountKeys1.length > 0) {\n            this.browserStorage.setItem(\n                CacheKeys.getAccountKeysCacheKey(1),\n                JSON.stringify(accountKeys1)\n            );\n        } else {\n            this.browserStorage.removeItem(CacheKeys.getAccountKeysCacheKey(1));\n        }\n\n        this.setTokenKeys(tokenKeys0, correlationId, 0);\n        this.setTokenKeys(tokenKeys1, correlationId, 1);\n    }\n\n    async updateV0ToCurrent(\n        currentSchema: number,\n        v0Keys: Array<string>,\n        v1Keys: Array<string>,\n        correlationId: string\n    ): Promise<void[]> {\n        const upgradePromises: Array<Promise<void>> = [];\n\n        for (const v0Key of [...v0Keys]) {\n            const rawV0Value = this.browserStorage.getItem(v0Key);\n            const parsedV0Value = this.validateAndParseJson(\n                rawV0Value || \"\"\n            ) as CredentialEntity | AccountEntity | EncryptedData | null;\n\n            if (!parsedV0Value) {\n                removeElementFromArray(v0Keys, v0Key);\n                continue;\n            }\n\n            if (!parsedV0Value.lastUpdatedAt) {\n                // Add lastUpdatedAt to the existing v0 entry if it doesnt exist so we know when it's safe to remove it\n                parsedV0Value.lastUpdatedAt = Date.now().toString();\n                this.setItem(\n                    v0Key,\n                    JSON.stringify(parsedV0Value),\n                    correlationId\n                );\n            }\n\n            const decryptedData = isEncrypted(parsedV0Value)\n                ? await this.browserStorage.decryptData(\n                      v0Key,\n                      parsedV0Value,\n                      correlationId\n                  )\n                : parsedV0Value;\n            let expirationTime;\n            if (decryptedData) {\n                if (CacheHelpers.isAccessTokenEntity(decryptedData)) {\n                    expirationTime = decryptedData.expiresOn;\n                } else if (CacheHelpers.isRefreshTokenEntity(decryptedData)) {\n                    expirationTime = decryptedData.expiresOn;\n                }\n            }\n            if (\n                !decryptedData ||\n                TimeUtils.isCacheExpired(\n                    parsedV0Value.lastUpdatedAt,\n                    this.cacheConfig.cacheRetentionDays\n                ) ||\n                (expirationTime &&\n                    TimeUtils.isTokenExpired(\n                        expirationTime,\n                        DEFAULT_TOKEN_RENEWAL_OFFSET_SEC\n                    ))\n            ) {\n                this.browserStorage.removeItem(v0Key);\n                removeElementFromArray(v0Keys, v0Key);\n                this.performanceClient.incrementFields(\n                    { expiredCacheRemovedCount: 1 },\n                    correlationId\n                );\n                continue;\n            }\n\n            if (\n                this.cacheConfig.cacheLocation !==\n                    BrowserCacheLocation.LocalStorage ||\n                isEncrypted(parsedV0Value)\n            ) {\n                const v1Key = `${CacheKeys.PREFIX}.${currentSchema}${CacheKeys.CACHE_KEY_SEPARATOR}${v0Key}`;\n                const rawV1Entry = this.browserStorage.getItem(v1Key);\n                if (!rawV1Entry) {\n                    upgradePromises.push(\n                        this.setUserData(\n                            v1Key,\n                            JSON.stringify(decryptedData),\n                            correlationId,\n                            parsedV0Value.lastUpdatedAt\n                        ).then(() => {\n                            v1Keys.push(v1Key);\n                            this.performanceClient.incrementFields(\n                                { upgradedCacheCount: 1 },\n                                correlationId\n                            );\n                        })\n                    );\n                    continue;\n                } else {\n                    const parsedV1Entry = this.validateAndParseJson(\n                        rawV1Entry\n                    ) as CredentialEntity | AccountEntity | EncryptedData;\n                    // If the entry already exists but is older than the v0 entry, replace it\n                    if (\n                        Number(parsedV0Value.lastUpdatedAt) >\n                        Number(parsedV1Entry.lastUpdatedAt)\n                    ) {\n                        upgradePromises.push(\n                            this.setUserData(\n                                v1Key,\n                                JSON.stringify(decryptedData),\n                                correlationId,\n                                parsedV0Value.lastUpdatedAt\n                            ).then(() => {\n                                this.performanceClient.incrementFields(\n                                    { updatedCacheFromV0Count: 1 },\n                                    correlationId\n                                );\n                            })\n                        );\n                        continue;\n                    }\n                }\n            }\n            /*\n             * Note: If we reach here for unencrypted localStorage data, we continue without migrating\n             * as we can't migrate unencrypted localStorage data right now since we can't guarantee KMSI=no\n             */\n        }\n\n        return Promise.all(upgradePromises);\n    }\n\n    /**\n     * Tracks upgrades and downgrades for telemetry and debugging purposes\n     */\n    private trackVersionChanges(correlationId: string): void {\n        const previousVersion = this.browserStorage.getItem(\n            CacheKeys.VERSION_CACHE_KEY\n        );\n        if (previousVersion) {\n            this.logger.info(\n                `MSAL.js was last initialized by version: ${previousVersion}`\n            );\n            this.performanceClient.addFields(\n                { previousLibraryVersion: previousVersion },\n                correlationId\n            );\n        }\n\n        if (previousVersion !== version) {\n            this.setItem(CacheKeys.VERSION_CACHE_KEY, version, correlationId);\n        }\n    }\n\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    protected validateAndParseJson(jsonValue: string): object | null {\n        if (!jsonValue) {\n            return null;\n        }\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return parsedJson && typeof parsedJson === \"object\"\n                ? parsedJson\n                : null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * Helper to setItem in browser storage, with cleanup in case of quota errors\n     * @param key\n     * @param value\n     */\n    setItem(key: string, value: string, correlationId: string): void {\n        let tokenKeysV0Count = 0;\n        let accessTokenKeys: Array<string> = [];\n        const maxRetries = 20;\n        for (let i = 0; i <= maxRetries; i++) {\n            try {\n                this.browserStorage.setItem(key, value);\n                if (i > 0) {\n                    // Finally update the token keys array with the tokens removed\n                    if (i <= tokenKeysV0Count) {\n                        this.removeAccessTokenKeys(\n                            accessTokenKeys.slice(0, i),\n                            correlationId,\n                            0\n                        );\n                    } else {\n                        this.removeAccessTokenKeys(\n                            accessTokenKeys.slice(0, tokenKeysV0Count),\n                            correlationId,\n                            0\n                        );\n                        this.removeAccessTokenKeys(\n                            accessTokenKeys.slice(tokenKeysV0Count, i),\n                            correlationId\n                        );\n                    }\n                }\n                break; // If setItem succeeds, exit the loop\n            } catch (e) {\n                const cacheError = createCacheError(e);\n                if (\n                    cacheError.errorCode ===\n                        CacheErrorCodes.cacheQuotaExceeded &&\n                    i < maxRetries\n                ) {\n                    if (!accessTokenKeys.length) {\n                        // If we are currently trying to set the token keys, use the value we're trying to set\n                        const tokenKeys0 =\n                            key ===\n                            CacheKeys.getTokenKeysCacheKey(this.clientId, 0)\n                                ? (JSON.parse(value) as TokenKeys).accessToken\n                                : this.getTokenKeys(0).accessToken;\n                        const tokenKeys1 =\n                            key ===\n                            CacheKeys.getTokenKeysCacheKey(this.clientId)\n                                ? (JSON.parse(value) as TokenKeys).accessToken\n                                : this.getTokenKeys().accessToken;\n                        accessTokenKeys = [...tokenKeys0, ...tokenKeys1];\n                        tokenKeysV0Count = tokenKeys0.length;\n                    }\n                    if (accessTokenKeys.length <= i) {\n                        // Nothing to remove, rethrow the error\n                        throw cacheError;\n                    }\n                    // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n                    this.removeAccessToken(\n                        accessTokenKeys[i],\n                        correlationId,\n                        false // Don't save token keys yet, do it at the end\n                    );\n                } else {\n                    // If the error is not a quota exceeded error, rethrow it\n                    throw cacheError;\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper to setUserData in browser storage, with cleanup in case of quota errors\n     * @param key\n     * @param value\n     * @param correlationId\n     */\n    async setUserData(\n        key: string,\n        value: string,\n        correlationId: string,\n        timestamp: string\n    ): Promise<void> {\n        let tokenKeysV0Count = 0;\n        let accessTokenKeys: Array<string> = [];\n        const maxRetries = 20;\n        for (let i = 0; i <= maxRetries; i++) {\n            try {\n                await invokeAsync(\n                    this.browserStorage.setUserData.bind(this.browserStorage),\n                    PerformanceEvents.SetUserData,\n                    this.logger,\n                    this.performanceClient\n                )(key, value, correlationId, timestamp);\n                if (i > 0) {\n                    // Finally update the token keys array with the tokens removed\n                    if (i <= tokenKeysV0Count) {\n                        this.removeAccessTokenKeys(\n                            accessTokenKeys.slice(0, i),\n                            correlationId,\n                            0\n                        );\n                    } else {\n                        this.removeAccessTokenKeys(\n                            accessTokenKeys.slice(0, tokenKeysV0Count),\n                            correlationId,\n                            0\n                        );\n                        this.removeAccessTokenKeys(\n                            accessTokenKeys.slice(tokenKeysV0Count, i),\n                            correlationId\n                        );\n                    }\n                }\n                break; // If setItem succeeds, exit the loop\n            } catch (e) {\n                const cacheError = createCacheError(e);\n                if (\n                    cacheError.errorCode ===\n                        CacheErrorCodes.cacheQuotaExceeded &&\n                    i < maxRetries\n                ) {\n                    if (!accessTokenKeys.length) {\n                        const tokenKeys0 = this.getTokenKeys(0).accessToken;\n                        const tokenKeys1 = this.getTokenKeys().accessToken;\n                        accessTokenKeys = [...tokenKeys0, ...tokenKeys1];\n                        tokenKeysV0Count = tokenKeys0.length;\n                    }\n                    if (accessTokenKeys.length <= i) {\n                        // Nothing left to remove, rethrow the error\n                        throw cacheError;\n                    }\n                    // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n                    this.removeAccessToken(\n                        accessTokenKeys[i],\n                        correlationId,\n                        false // Don't save token keys yet, do it at the end\n                    );\n                } else {\n                    // If the error is not a quota exceeded error, rethrow it\n                    throw cacheError;\n                }\n            }\n        }\n    }\n\n    /**\n     * Reads account from cache, deserializes it into an account entity and returns it.\n     * If account is not found from the key, returns null and removes key from map.\n     * @param accountKey\n     * @returns\n     */\n    getAccount(\n        accountKey: string,\n        correlationId: string\n    ): AccountEntity | null {\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\n        const serializedAccount = this.browserStorage.getUserData(accountKey);\n        if (!serializedAccount) {\n            this.removeAccountKeyFromMap(accountKey, correlationId);\n            return null;\n        }\n\n        const parsedAccount = this.validateAndParseJson(serializedAccount);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            return null;\n        }\n\n        return CacheManager.toObject<AccountEntity>(\n            new AccountEntity(),\n            parsedAccount\n        );\n    }\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    async setAccount(\n        account: AccountEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = this.generateAccountKey(account.getAccountInfo());\n        const timestamp = Date.now().toString();\n        account.lastUpdatedAt = timestamp;\n        await this.setUserData(\n            key,\n            JSON.stringify(account),\n            correlationId,\n            timestamp\n        );\n        const wasAdded = this.addAccountKeyToMap(key, correlationId);\n\n        /**\n         * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\n         */\n        if (\n            this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage &&\n            wasAdded\n        ) {\n            this.eventHandler.emitEvent(\n                EventType.ACCOUNT_ADDED,\n                undefined,\n                account.getAccountInfo()\n            );\n        }\n    }\n\n    /**\n     * Returns the array of account keys currently cached\n     * @returns\n     */\n    getAccountKeys(): Array<string> {\n        return getAccountKeys(this.browserStorage);\n    }\n\n    /**\n     * Add a new account to the key map\n     * @param key\n     */\n    addAccountKeyToMap(key: string, correlationId: string): boolean {\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.addAccountKeyToMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        if (accountKeys.indexOf(key) === -1) {\n            // Only add key if it does not already exist in the map\n            accountKeys.push(key);\n            this.setItem(\n                CacheKeys.getAccountKeysCacheKey(),\n                JSON.stringify(accountKeys),\n                correlationId\n            );\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key added\"\n            );\n            return true;\n        } else {\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key already exists in map\"\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Remove an account from the key map\n     * @param key\n     */\n    removeAccountKeyFromMap(key: string, correlationId: string): void {\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        const removalIndex = accountKeys.indexOf(key);\n        if (removalIndex > -1) {\n            accountKeys.splice(removalIndex, 1);\n            if (accountKeys.length === 0) {\n                // If no keys left, remove the map\n                this.removeItem(CacheKeys.getAccountKeysCacheKey());\n                return;\n            } else {\n                this.setItem(\n                    CacheKeys.getAccountKeysCacheKey(),\n                    JSON.stringify(accountKeys),\n                    correlationId\n                );\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap account key removed\"\n            );\n        } else {\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\"\n            );\n        }\n    }\n\n    /**\n     * Extends inherited removeAccount function to include removal of the account key from the map\n     * @param key\n     */\n    removeAccount(account: AccountInfo, correlationId: string): void {\n        const activeAccount = this.getActiveAccount(correlationId);\n        if (\n            activeAccount?.homeAccountId === account.homeAccountId &&\n            activeAccount?.environment === account.environment\n        ) {\n            this.setActiveAccount(null, correlationId);\n        }\n\n        super.removeAccount(account, correlationId);\n        this.removeAccountKeyFromMap(\n            this.generateAccountKey(account),\n            correlationId\n        );\n\n        // Remove all other associated cache items\n        this.browserStorage.getKeys().forEach((key) => {\n            if (\n                key.includes(account.homeAccountId) &&\n                key.includes(account.environment)\n            ) {\n                this.browserStorage.removeItem(key);\n            }\n        });\n\n        /**\n         * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\n         */\n        if (\n            this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage\n        ) {\n            this.eventHandler.emitEvent(\n                EventType.ACCOUNT_REMOVED,\n                undefined,\n                account\n            );\n        }\n    }\n\n    /**\n     * Removes given idToken from the cache and from the key map\n     * @param key\n     */\n    removeIdToken(key: string, correlationId: string): void {\n        super.removeIdToken(key, correlationId);\n        const tokenKeys = this.getTokenKeys();\n        const idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n            this.logger.info(\"idToken removed from tokenKeys map\");\n            tokenKeys.idToken.splice(idRemoval, 1);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * Removes given accessToken from the cache and from the key map\n     * @param key\n     */\n    removeAccessToken(\n        key: string,\n        correlationId: string,\n        updateTokenKeys: boolean = true\n    ): void {\n        super.removeAccessToken(key, correlationId);\n        updateTokenKeys && this.removeAccessTokenKeys([key], correlationId);\n    }\n\n    /**\n     * Remove access token key from the key map\n     * @param key\n     * @param correlationId\n     * @param tokenKeys\n     */\n    removeAccessTokenKeys(\n        keys: Array<string>,\n        correlationId: string,\n        schemaVersion: number = CacheKeys.CREDENTIAL_SCHEMA_VERSION\n    ): void {\n        this.logger.trace(\"removeAccessTokenKey called\");\n        const tokenKeys = this.getTokenKeys(schemaVersion);\n        let keysRemoved = 0;\n        keys.forEach((key) => {\n            const accessRemoval = tokenKeys.accessToken.indexOf(key);\n            if (accessRemoval > -1) {\n                tokenKeys.accessToken.splice(accessRemoval, 1);\n                keysRemoved++;\n            }\n        });\n\n        if (keysRemoved > 0) {\n            this.logger.info(\n                `removed ${keysRemoved} accessToken keys from tokenKeys map`\n            );\n            this.setTokenKeys(tokenKeys, correlationId, schemaVersion);\n            return;\n        }\n    }\n\n    /**\n     * Removes given refreshToken from the cache and from the key map\n     * @param key\n     */\n    removeRefreshToken(key: string, correlationId: string): void {\n        super.removeRefreshToken(key, correlationId);\n        const tokenKeys = this.getTokenKeys();\n        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n            this.logger.info(\"refreshToken removed from tokenKeys map\");\n            tokenKeys.refreshToken.splice(refreshRemoval, 1);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * Gets the keys for the cached tokens associated with this clientId\n     * @returns\n     */\n    getTokenKeys(\n        schemaVersion: number = CacheKeys.CREDENTIAL_SCHEMA_VERSION\n    ): TokenKeys {\n        return getTokenKeys(this.clientId, this.browserStorage, schemaVersion);\n    }\n\n    /**\n     * Stores the token keys in the cache\n     * @param tokenKeys\n     * @param correlationId\n     * @returns\n     */\n    setTokenKeys(\n        tokenKeys: TokenKeys,\n        correlationId: string,\n        schemaVersion: number = CacheKeys.CREDENTIAL_SCHEMA_VERSION\n    ): void {\n        if (\n            tokenKeys.idToken.length === 0 &&\n            tokenKeys.accessToken.length === 0 &&\n            tokenKeys.refreshToken.length === 0\n        ) {\n            // If no keys left, remove the map\n            this.removeItem(\n                CacheKeys.getTokenKeysCacheKey(this.clientId, schemaVersion)\n            );\n            return;\n        } else {\n            this.setItem(\n                CacheKeys.getTokenKeysCacheKey(this.clientId, schemaVersion),\n                JSON.stringify(tokenKeys),\n                correlationId\n            );\n        }\n    }\n\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(\n        idTokenKey: string,\n        correlationId: string\n    ): IdTokenEntity | null {\n        const value = this.browserStorage.getUserData(idTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            this.removeIdToken(idTokenKey, correlationId);\n            return null;\n        }\n\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getIdTokenCredential: cache hit\"\n        );\n        return parsedIdToken as IdTokenEntity;\n    }\n\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    async setIdTokenCredential(\n        idToken: IdTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = this.generateCredentialKey(idToken);\n        const timestamp = Date.now().toString();\n        idToken.lastUpdatedAt = timestamp;\n\n        await this.setUserData(\n            idTokenKey,\n            JSON.stringify(idToken),\n            correlationId,\n            timestamp\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        if (tokenKeys.idToken.indexOf(idTokenKey) === -1) {\n            this.logger.info(\n                \"BrowserCacheManager: addTokenKey - idToken added to map\"\n            );\n            tokenKeys.idToken.push(idTokenKey);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(\n        accessTokenKey: string,\n        correlationId: string\n    ): AccessTokenEntity | null {\n        const value = this.browserStorage.getUserData(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            this.removeAccessTokenKeys([accessTokenKey], correlationId);\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (\n            !parsedAccessToken ||\n            !CacheHelpers.isAccessTokenEntity(parsedAccessToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getAccessTokenCredential: cache hit\"\n        );\n        return parsedAccessToken as AccessTokenEntity;\n    }\n\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    async setAccessTokenCredential(\n        accessToken: AccessTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\n            \"BrowserCacheManager.setAccessTokenCredential called\"\n        );\n        const accessTokenKey = this.generateCredentialKey(accessToken);\n        const timestamp = Date.now().toString();\n        accessToken.lastUpdatedAt = timestamp;\n\n        await this.setUserData(\n            accessTokenKey,\n            JSON.stringify(accessToken),\n            correlationId,\n            timestamp\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        const index = tokenKeys.accessToken.indexOf(accessTokenKey);\n        if (index !== -1) {\n            tokenKeys.accessToken.splice(index, 1); // Remove existing key before pushing to the end\n        }\n        this.logger.trace(\n            `access token ${index === -1 ? \"added to\" : \"updated in\"} map`\n        );\n        tokenKeys.accessToken.push(accessTokenKey);\n        this.setTokenKeys(tokenKeys, correlationId);\n    }\n\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(\n        refreshTokenKey: string,\n        correlationId: string\n    ): RefreshTokenEntity | null {\n        const value = this.browserStorage.getUserData(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            this.removeRefreshToken(refreshTokenKey, correlationId);\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (\n            !parsedRefreshToken ||\n            !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getRefreshTokenCredential: cache hit\"\n        );\n        return parsedRefreshToken as RefreshTokenEntity;\n    }\n\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    async setRefreshTokenCredential(\n        refreshToken: RefreshTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\n            \"BrowserCacheManager.setRefreshTokenCredential called\"\n        );\n        const refreshTokenKey = this.generateCredentialKey(refreshToken);\n        const timestamp = Date.now().toString();\n        refreshToken.lastUpdatedAt = timestamp;\n\n        await this.setUserData(\n            refreshTokenKey,\n            JSON.stringify(refreshToken),\n            correlationId,\n            timestamp\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        if (tokenKeys.refreshToken.indexOf(refreshTokenKey) === -1) {\n            this.logger.info(\n                \"BrowserCacheManager: addTokenKey - refreshToken added to map\"\n            );\n            tokenKeys.refreshToken.push(refreshTokenKey);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const value = this.browserStorage.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            !parsedMetadata ||\n            !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return parsedMetadata as AppMetadataEntity;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(\n        appMetadata: AppMetadataEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n        this.setItem(\n            appMetadataKey,\n            JSON.stringify(appMetadata),\n            correlationId\n        );\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(\n        serverTelemetryKey: string\n    ): ServerTelemetryEntity | null {\n        const value = this.browserStorage.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedEntity = this.validateAndParseJson(value);\n        if (\n            !parsedEntity ||\n            !CacheHelpers.isServerTelemetryEntity(\n                serverTelemetryKey,\n                parsedEntity\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return parsedEntity as ServerTelemetryEntity;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.setItem(\n            serverTelemetryKey,\n            JSON.stringify(serverTelemetry),\n            correlationId\n        );\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            parsedMetadata &&\n            CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: cache hit\"\n            );\n            return parsedMetadata as AuthorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU\n     * @param wrapperVersion\n     */\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(\n            InMemoryCacheKeys.WRAPPER_VER,\n            wrapperVersion\n        );\n    }\n\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata(): [string, string] {\n        const sku =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) ||\n            Constants.EMPTY_STRING;\n        const version =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) ||\n            Constants.EMPTY_STRING;\n        return [sku, version];\n    }\n\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n\n    /**\n     * Gets the active account\n     */\n    getActiveAccount(correlationId: string): AccountInfo | null {\n        const activeAccountKeyFilters = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        const activeAccountValueFilters = this.browserStorage.getItem(\n            activeAccountKeyFilters\n        );\n        if (!activeAccountValueFilters) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: No active account filters found\"\n            );\n            return null;\n        }\n        const activeAccountValueObj = this.validateAndParseJson(\n            activeAccountValueFilters\n        ) as AccountInfo;\n        if (activeAccountValueObj) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: Active account filters schema found\"\n            );\n            return this.getAccountInfoFilteredBy(\n                {\n                    homeAccountId: activeAccountValueObj.homeAccountId,\n                    localAccountId: activeAccountValueObj.localAccountId,\n                    tenantId: activeAccountValueObj.tenantId,\n                },\n                correlationId\n            );\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getActiveAccount: No active account found\"\n        );\n        return null;\n    }\n\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null, correlationId: string): void {\n        const activeAccountKey = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            const activeAccountValue: ActiveAccountFilters = {\n                homeAccountId: account.homeAccountId,\n                localAccountId: account.localAccountId,\n                tenantId: account.tenantId,\n                lastUpdatedAt: TimeUtils.nowSeconds().toString(),\n            };\n            this.setItem(\n                activeAccountKey,\n                JSON.stringify(activeAccountValue),\n                correlationId\n            );\n        } else {\n            this.logger.verbose(\n                \"setActiveAccount: No account passed, active account not set\"\n            );\n            this.browserStorage.removeItem(activeAccountKey);\n        }\n        this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const value = this.browserStorage.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (\n            !parsedThrottlingCache ||\n            !CacheHelpers.isThrottlingEntity(\n                throttlingCacheKey,\n                parsedThrottlingCache\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return parsedThrottlingCache as ThrottlingEntity;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.setItem(\n            throttlingCacheKey,\n            JSON.stringify(throttlingCache),\n            correlationId\n        );\n    }\n\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.cookieStorage.getItem(key);\n            if (itemCookie) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\"\n                );\n                return itemCookie;\n            }\n        }\n\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (\n                this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage\n            ) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\n                        \"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\"\n                    );\n                    return item;\n                }\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\"\n            );\n            return null;\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\"\n        );\n        return value;\n    }\n\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(\n        cacheKey: string,\n        value: string,\n        generateKey?: boolean\n    ): void {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\"\n            );\n            this.cookieStorage.setItem(\n                key,\n                value,\n                undefined,\n                this.cacheConfig.secureCookies\n            );\n        }\n    }\n\n    /**\n     * Removes the cache item with the given key.\n     * @param key\n     */\n    removeItem(key: string): void {\n        this.browserStorage.removeItem(key);\n    }\n\n    /**\n     * Removes the temporary cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeTemporaryItem(key: string): void {\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\"\n            );\n            this.cookieStorage.removeItem(key);\n        }\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        return this.browserStorage.getKeys();\n    }\n\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    clear(correlationId: string): void {\n        // Removes all accounts and their credentials\n        this.removeAllAccounts(correlationId);\n        this.removeAppMetadata(correlationId);\n\n        // Remove temp storage first to make sure any cookies are cleared\n        this.temporaryCacheStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(CacheKeys.PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.removeTemporaryItem(cacheKey);\n            }\n        });\n\n        // Removes all remaining MSAL cache items\n        this.browserStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(CacheKeys.PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.browserStorage.removeItem(cacheKey);\n            }\n        });\n\n        this.internalStorage.clear();\n    }\n\n    /**\n     * Clears all access tokes that have claims prior to saving the current one\n     * @param performanceClient {IPerformanceClient}\n     * @param correlationId {string} correlation id\n     * @returns\n     */\n    clearTokensAndKeysWithClaims(correlationId: string): void {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.ClearTokensAndKeysWithClaims,\n            correlationId\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        let removedAccessTokens = 0;\n        tokenKeys.accessToken.forEach((key: string) => {\n            // if the access token has claims in its key, remove the token key and the token\n            const credential = this.getAccessTokenCredential(\n                key,\n                correlationId\n            );\n            if (\n                credential?.requestedClaimsHash &&\n                key.includes(credential.requestedClaimsHash.toLowerCase())\n            ) {\n                this.removeAccessToken(key, correlationId);\n                removedAccessTokens++;\n            }\n        });\n\n        // warn if any access tokens are removed\n        if (removedAccessTokens > 0) {\n            this.logger.warning(\n                `${removedAccessTokens} access tokens with claims in the cache keys have been removed from the cache.`\n            );\n        }\n    }\n\n    /**\n     * Prepend msal.<client-id> to each key\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key: string): string {\n        if (StringUtils.startsWith(key, CacheKeys.PREFIX)) {\n            return key;\n        }\n        return `${CacheKeys.PREFIX}.${this.clientId}.${key}`;\n    }\n\n    /**\n     * Cache Key: msal.<schema_version>-<home_account_id>-<environment>-<credential_type>-<client_id or familyId>-<realm>-<scopes>-<claims hash>-<scheme>\n     * IdToken Example: uid.utid-login.microsoftonline.com-idtoken-app_client_id-contoso.com\n     * AccessToken Example: uid.utid-login.microsoftonline.com-accesstoken-app_client_id-contoso.com-scope1 scope2--pop\n     * RefreshToken Example: uid.utid-login.microsoftonline.com-refreshtoken-1-contoso.com\n     * @param credentialEntity\n     * @returns\n     */\n    generateCredentialKey(credential: CredentialEntity): string {\n        const familyId =\n            (credential.credentialType === CredentialType.REFRESH_TOKEN &&\n                credential.familyId) ||\n            credential.clientId;\n        const scheme =\n            credential.tokenType &&\n            credential.tokenType.toLowerCase() !==\n                AuthenticationScheme.BEARER.toLowerCase()\n                ? credential.tokenType.toLowerCase()\n                : \"\";\n        const credentialKey = [\n            `${CacheKeys.PREFIX}.${CacheKeys.CREDENTIAL_SCHEMA_VERSION}`,\n            credential.homeAccountId,\n            credential.environment,\n            credential.credentialType,\n            familyId,\n            credential.realm || \"\",\n            credential.target || \"\",\n            credential.requestedClaimsHash || \"\",\n            scheme,\n        ];\n\n        return credentialKey.join(CacheKeys.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Cache Key: msal.<schema_version>.<home_account_id>.<environment>.<tenant_id>\n     * @param account\n     * @returns\n     */\n    generateAccountKey(account: AccountInfo): string {\n        const homeTenantId = account.homeAccountId.split(\".\")[1];\n        const accountKey = [\n            `${CacheKeys.PREFIX}.${CacheKeys.ACCOUNT_SCHEMA_VERSION}`,\n            account.homeAccountId,\n            account.environment,\n            homeTenantId || account.tenantId || \"\",\n        ];\n\n        return accountKey.join(CacheKeys.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(): void {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.VERIFIER)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.URL_HASH)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)\n        );\n        this.setInteractionInProgress(false);\n    }\n\n    cacheAuthorizeRequest(\n        authCodeRequest: CommonAuthorizationUrlRequest,\n        codeVerifier?: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.cacheAuthorizeRequest called\");\n\n        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            encodedValue,\n            true\n        );\n\n        if (codeVerifier) {\n            const encodedVerifier = base64Encode(codeVerifier);\n            this.setTemporaryCache(\n                TemporaryCacheKeys.VERIFIER,\n                encodedVerifier,\n                true\n            );\n        }\n    }\n\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(): [CommonAuthorizationUrlRequest, string] {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            true\n        );\n        if (!encodedTokenRequest) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.noTokenRequestCacheError\n            );\n        }\n        const encodedVerifier = this.getTemporaryCache(\n            TemporaryCacheKeys.VERIFIER,\n            true\n        );\n\n        let parsedRequest: CommonAuthorizationUrlRequest;\n        let verifier = \"\";\n        try {\n            parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n            if (encodedVerifier) {\n                verifier = base64Decode(encodedVerifier);\n            }\n        } catch (e) {\n            this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n            this.logger.error(\n                `Parsing cached token request threw with error: ${e}`\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToParseTokenRequestCacheError\n            );\n        }\n\n        return [parsedRequest, verifier];\n    }\n\n    /**\n     * Gets cached native request for redirect flows\n     */\n    getCachedNativeRequest(): PlatformAuthRequest | null {\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n        const cachedRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.NATIVE_REQUEST,\n            true\n        );\n        if (!cachedRequest) {\n            this.logger.trace(\n                \"BrowserCacheManager.getCachedNativeRequest: No cached native request found\"\n            );\n            return null;\n        }\n\n        const parsedRequest = this.validateAndParseJson(\n            cachedRequest\n        ) as PlatformAuthRequest;\n        if (!parsedRequest) {\n            this.logger.error(\n                \"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\"\n            );\n            return null;\n        }\n\n        return parsedRequest;\n    }\n\n    isInteractionInProgress(matchClientId?: boolean): boolean {\n        const clientId = this.getInteractionInProgress()?.clientId;\n\n        if (matchClientId) {\n            return clientId === this.clientId;\n        } else {\n            return !!clientId;\n        }\n    }\n\n    getInteractionInProgress(): {\n        clientId: string;\n        type: INTERACTION_TYPE;\n    } | null {\n        const key = `${CacheKeys.PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        const value = this.getTemporaryCache(key, false);\n        try {\n            return value ? JSON.parse(value) : null;\n        } catch (e) {\n            // Remove interaction and other temp keys if interaction status can't be parsed\n            this.logger.error(\n                `Cannot parse interaction status. Removing temporary cache items and clearing url hash. Retrying interaction should fix the error`\n            );\n            this.removeTemporaryItem(key);\n            this.resetRequestCache();\n            clearHash(window);\n            return null;\n        }\n    }\n\n    setInteractionInProgress(\n        inProgress: boolean,\n        type: INTERACTION_TYPE = INTERACTION_TYPE.SIGNIN\n    ): void {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${CacheKeys.PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.interactionInProgress\n                );\n            } else {\n                // No interaction is in progress\n                this.setTemporaryCache(\n                    key,\n                    JSON.stringify({ clientId: this.clientId, type }),\n                    false\n                );\n            }\n        } else if (\n            !inProgress &&\n            this.getInteractionInProgress()?.clientId === this.clientId\n        ) {\n            this.removeTemporaryItem(key);\n        }\n    }\n\n    /**\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n     * @param result\n     * @param request\n     */\n    async hydrateCache(\n        result: AuthenticationResult,\n        request:\n            | SilentRequest\n            | SsoSilentRequest\n            | RedirectRequest\n            | PopupRequest\n    ): Promise<void> {\n        const idTokenEntity = CacheHelpers.createIdTokenEntity(\n            result.account?.homeAccountId,\n            result.account?.environment,\n            result.idToken,\n            this.clientId,\n            result.tenantId\n        );\n\n        let claimsHash;\n        if (request.claims) {\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\n        }\n\n        /**\n         * meta data for cache stores time in seconds from epoch\n         * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\n         * We need to map these for the cache when building tokens from AuthenticationResult\n         *\n         * The next MSAL VFuture should map these both to same value if possible\n         */\n\n        const accessTokenEntity = CacheHelpers.createAccessTokenEntity(\n            result.account?.homeAccountId,\n            result.account.environment,\n            result.accessToken,\n            this.clientId,\n            result.tenantId,\n            result.scopes.join(\" \"),\n            // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date\n            result.expiresOn\n                ? TimeUtils.toSecondsFromDate(result.expiresOn)\n                : 0,\n            result.extExpiresOn\n                ? TimeUtils.toSecondsFromDate(result.extExpiresOn)\n                : 0,\n            base64Decode,\n            undefined, // refreshOn\n            result.tokenType as AuthenticationScheme,\n            undefined, // userAssertionHash\n            request.sshKid,\n            request.claims,\n            claimsHash\n        );\n\n        const cacheRecord = {\n            idToken: idTokenEntity,\n            accessToken: accessTokenEntity,\n        };\n        return this.saveCacheRecord(cacheRecord, result.correlationId);\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord {CacheRecord}\n     * @param storeInCache {?StoreInCache}\n     * @param correlationId {?string} correlation id\n     */\n    async saveCacheRecord(\n        cacheRecord: CacheRecord,\n        correlationId: string,\n        storeInCache?: StoreInCache\n    ): Promise<void> {\n        try {\n            await super.saveCacheRecord(\n                cacheRecord,\n                correlationId,\n                storeInCache\n            );\n        } catch (e) {\n            if (\n                e instanceof CacheError &&\n                this.performanceClient &&\n                correlationId\n            ) {\n                try {\n                    const tokenKeys = this.getTokenKeys();\n\n                    this.performanceClient.addFields(\n                        {\n                            cacheRtCount: tokenKeys.refreshToken.length,\n                            cacheIdCount: tokenKeys.idToken.length,\n                            cacheAtCount: tokenKeys.accessToken.length,\n                        },\n                        correlationId\n                    );\n                } catch (e) {}\n            }\n\n            throw e;\n        }\n    }\n}\n\n/**\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n * @param cacheLocation\n */\nfunction getStorageImplementation(\n    clientId: string,\n    cacheLocation: BrowserCacheLocation | string,\n    logger: Logger,\n    performanceClient: IPerformanceClient\n): IWindowStorage<string> {\n    try {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n                return new LocalStorage(clientId, logger, performanceClient);\n            case BrowserCacheLocation.SessionStorage:\n                return new SessionStorage();\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                break;\n        }\n    } catch (e) {\n        logger.error(e as string);\n    }\n\n    return new MemoryStorage();\n}\n\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (\n    clientId: string,\n    logger: Logger,\n    performanceClient: IPerformanceClient,\n    eventHandler: EventHandler\n): BrowserCacheManager => {\n    const cacheOptions: Required<CacheOptions> = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        cacheRetentionDays: 5,\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false,\n        cacheMigrationEnabled: false,\n        claimsBasedCachingEnabled: false,\n    };\n    return new BrowserCacheManager(\n        clientId,\n        cacheOptions,\n        DEFAULT_CRYPTO_IMPLEMENTATION,\n        logger,\n        performanceClient,\n        eventHandler\n    );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}