{"ast":null,"code":"/*! @azure/msal-browser v4.24.1 2025-09-30 */\n'use strict';\n\nimport _objectSpread from \"C:/_Projects/DGL_ToDo/react_todo_dashboard2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { invokeAsync, PerformanceEvents, ProtocolMode, AuthError, HttpMethod, Constants, UrlUtils, UrlString, ServerResponseType } from '@azure/msal-common/browser';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { InteractionType, TemporaryCacheKeys, ApiId, INTERACTION_TYPE } from '../utils/BrowserConstants.mjs';\nimport { replaceHash, isInIframe, getHomepage, clearHash, getCurrentUri } from '../utils/BrowserUtils.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { validateInteractionType } from '../response/ResponseHandler.mjs';\nimport { getAuthCodeRequestUrl, getEARForm, getCodeForm, handleResponseEAR, handleResponseCode } from '../protocol/Authorize.mjs';\nimport { generatePkceCodes } from '../crypto/PkceGenerator.mjs';\nimport { isPlatformAuthAllowed } from '../broker/nativeBroker/PlatformAuthProvider.mjs';\nimport { generateEarKey } from '../crypto/BrowserCrypto.mjs';\nimport { timedOut, noStateInHash, emptyNavigateUri } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getNavigationType() {\n  if (typeof window === \"undefined\" || typeof window.performance === \"undefined\" || typeof window.performance.getEntriesByType !== \"function\") {\n    return undefined;\n  }\n  const navigationEntries = window.performance.getEntriesByType(\"navigation\");\n  const navigation = navigationEntries.length ? navigationEntries[0] : undefined;\n  return navigation === null || navigation === void 0 ? void 0 : navigation.type;\n}\nclass RedirectClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, platformAuthHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, platformAuthHandler, correlationId);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\r\n   * Redirects the page to the /authorize endpoint of the IDP\r\n   * @param request\r\n   */\n  async acquireToken(request) {\n    const validRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, this.correlationId)(request, InteractionType.Redirect);\n    validRequest.platformBroker = isPlatformAuthAllowed(this.config, this.logger, this.platformAuthProvider, request.authenticationScheme);\n    const handleBackButton = event => {\n      // Clear temporary cache if the back button is clicked during the redirect flow.\n      if (event.persisted) {\n        this.logger.verbose(\"Page was restored from back/forward cache. Clearing temporary cache.\");\n        this.browserStorage.resetRequestCache();\n        this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);\n      }\n    };\n    const redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);\n    this.logger.verbosePii(\"Redirect start page: \".concat(redirectStartPage));\n    // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n    this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, redirectStartPage, true);\n    // Clear temporary cache if the back button is clicked during the redirect flow.\n    window.addEventListener(\"pageshow\", handleBackButton);\n    try {\n      if (this.config.auth.protocolMode === ProtocolMode.EAR) {\n        await this.executeEarFlow(validRequest);\n      } else {\n        await this.executeCodeFlow(validRequest, request.onRedirectNavigate);\n      }\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n      }\n      window.removeEventListener(\"pageshow\", handleBackButton);\n      throw e;\n    }\n  }\n  /**\r\n   * Executes auth code + PKCE flow\r\n   * @param request\r\n   * @returns\r\n   */\n  async executeCodeFlow(request, onRedirectNavigate) {\n    const correlationId = request.correlationId;\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);\n    const pkceCodes = await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);\n    const redirectRequest = _objectSpread(_objectSpread({}, request), {}, {\n      codeChallenge: pkceCodes.challenge\n    });\n    this.browserStorage.cacheAuthorizeRequest(redirectRequest, pkceCodes.verifier);\n    try {\n      if (redirectRequest.httpMethod === HttpMethod.POST) {\n        return await this.executeCodeFlowWithPost(redirectRequest);\n      } else {\n        // Initialize the client\n        const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({\n          serverTelemetryManager,\n          requestAuthority: redirectRequest.authority,\n          requestAzureCloudOptions: redirectRequest.azureCloudOptions,\n          requestExtraQueryParameters: redirectRequest.extraQueryParameters,\n          account: redirectRequest.account\n        });\n        // Create acquire token url.\n        const navigateUrl = await invokeAsync(getAuthCodeRequestUrl, PerformanceEvents.GetAuthCodeUrl, this.logger, this.performanceClient, request.correlationId)(this.config, authClient.authority, redirectRequest, this.logger, this.performanceClient);\n        // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n        return await this.initiateAuthRequest(navigateUrl, onRedirectNavigate);\n      }\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      throw e;\n    }\n  }\n  /**\r\n   * Executes EAR flow\r\n   * @param request\r\n   */\n  async executeEarFlow(request) {\n    const correlationId = request.correlationId;\n    // Get the frame handle for the silent request\n    const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({\n      requestAuthority: request.authority,\n      requestAzureCloudOptions: request.azureCloudOptions,\n      requestExtraQueryParameters: request.extraQueryParameters,\n      account: request.account\n    });\n    const earJwk = await invokeAsync(generateEarKey, PerformanceEvents.GenerateEarKey, this.logger, this.performanceClient, correlationId)();\n    const redirectRequest = _objectSpread(_objectSpread({}, request), {}, {\n      earJwk: earJwk\n    });\n    this.browserStorage.cacheAuthorizeRequest(redirectRequest);\n    const form = await getEARForm(document, this.config, discoveredAuthority, redirectRequest, this.logger, this.performanceClient);\n    form.submit();\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(createBrowserAuthError(timedOut, \"failed_to_redirect\"));\n      }, this.config.system.redirectNavigationTimeout);\n    });\n  }\n  /**\r\n   * Executes classic Authorization Code flow with a POST request.\r\n   * @param request\r\n   */\n  async executeCodeFlowWithPost(request) {\n    const correlationId = request.correlationId;\n    // Get the frame handle for the silent request\n    const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({\n      requestAuthority: request.authority,\n      requestAzureCloudOptions: request.azureCloudOptions,\n      requestExtraQueryParameters: request.extraQueryParameters,\n      account: request.account\n    });\n    this.browserStorage.cacheAuthorizeRequest(request);\n    const form = await getCodeForm(document, this.config, discoveredAuthority, request, this.logger, this.performanceClient);\n    form.submit();\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(createBrowserAuthError(timedOut, \"failed_to_redirect\"));\n      }, this.config.system.redirectNavigationTimeout);\n    });\n  }\n  /**\r\n   * Checks if navigateToLoginRequestUrl is set, and:\r\n   * - if true, performs logic to cache and navigate\r\n   * - if false, handles hash string and parses response\r\n   * @param hash {string} url hash\r\n   * @param parentMeasurement {InProgressPerformanceEvent} parent measurement\r\n   */\n  async handleRedirectPromise() {\n    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let request = arguments.length > 1 ? arguments[1] : undefined;\n    let pkceVerifier = arguments.length > 2 ? arguments[2] : undefined;\n    let parentMeasurement = arguments.length > 3 ? arguments[3] : undefined;\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);\n    try {\n      const [serverParams, responseString] = this.getRedirectResponse(hash || \"\");\n      if (!serverParams) {\n        // Not a recognized server response hash or hash not associated with a redirect request\n        this.logger.info(\"handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.\");\n        this.browserStorage.resetRequestCache();\n        // Do not instrument \"no_server_response\" if user clicked back button\n        if (getNavigationType() !== \"back_forward\") {\n          parentMeasurement.event.errorCode = \"no_server_response\";\n        } else {\n          this.logger.verbose(\"Back navigation event detected. Muting no_server_response error\");\n        }\n        return null;\n      }\n      // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n      const loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;\n      const loginRequestUrlNormalized = UrlUtils.normalizeUrlForComparison(loginRequestUrl);\n      const currentUrlNormalized = UrlUtils.normalizeUrlForComparison(window.location.href);\n      if (loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl) {\n        // We are on the page we need to navigate to - handle hash\n        this.logger.verbose(\"Current page is loginRequestUrl, handling response\");\n        if (loginRequestUrl.indexOf(\"#\") > -1) {\n          // Replace current hash with non-msal hash, if present\n          replaceHash(loginRequestUrl);\n        }\n        const handleHashResult = await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);\n        return handleHashResult;\n      } else if (!this.config.auth.navigateToLoginRequestUrl) {\n        this.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling response\");\n        return await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);\n      } else if (!isInIframe() || this.config.system.allowRedirectInIframe) {\n        /*\r\n         * Returned from authority using redirect - need to perform navigation before processing response\r\n         * Cache the hash to be retrieved after the next redirect\r\n         */\n        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseString, true);\n        const navigationOptions = {\n          apiId: ApiId.handleRedirectPromise,\n          timeout: this.config.system.redirectNavigationTimeout,\n          noHistory: true\n        };\n        /**\r\n         * Default behavior is to redirect to the start page and not process the hash now.\r\n         * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\r\n         */\n        let processHashOnRedirect = true;\n        if (!loginRequestUrl || loginRequestUrl === \"null\") {\n          // Redirect to home page if login request url is null (real null or the string null)\n          const homepage = getHomepage();\n          // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n          this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n          this.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n          processHashOnRedirect = await this.navigationClient.navigateInternal(homepage, navigationOptions);\n        } else {\n          // Navigate to page that initiated the redirect request\n          this.logger.verbose(\"Navigating to loginRequestUrl: \".concat(loginRequestUrl));\n          processHashOnRedirect = await this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);\n        }\n        // If navigateInternal implementation returns false, handle the hash now\n        if (!processHashOnRedirect) {\n          return await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);\n        }\n      }\n      return null;\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      throw e;\n    }\n  }\n  /**\r\n   * Gets the response hash for a redirect request\r\n   * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\r\n   * @param hash\r\n   */\n  getRedirectResponse(userProvidedResponse) {\n    this.logger.verbose(\"getRedirectResponseHash called\");\n    // Get current location hash from window or cache.\n    let responseString = userProvidedResponse;\n    if (!responseString) {\n      if (this.config.auth.OIDCOptions.serverResponseType === ServerResponseType.QUERY) {\n        responseString = window.location.search;\n      } else {\n        responseString = window.location.hash;\n      }\n    }\n    let response = UrlUtils.getDeserializedResponse(responseString);\n    if (response) {\n      try {\n        validateInteractionType(response, this.browserCrypto, InteractionType.Redirect);\n      } catch (e) {\n        if (e instanceof AuthError) {\n          this.logger.error(\"Interaction type validation failed due to \".concat(e.errorCode, \": \").concat(e.errorMessage));\n        }\n        return [null, \"\"];\n      }\n      clearHash(window);\n      this.logger.verbose(\"Hash contains known properties, returning response hash\");\n      return [response, responseString];\n    }\n    const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n    this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    if (cachedHash) {\n      response = UrlUtils.getDeserializedResponse(cachedHash);\n      if (response) {\n        this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n        return [response, cachedHash];\n      }\n    }\n    return [null, \"\"];\n  }\n  /**\r\n   * Checks if hash exists and handles in window.\r\n   * @param hash\r\n   * @param state\r\n   */\n  async handleResponse(serverParams, request, codeVerifier, serverTelemetryManager) {\n    const state = serverParams.state;\n    if (!state) {\n      throw createBrowserAuthError(noStateInHash);\n    }\n    if (serverParams.ear_jwe) {\n      const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, request.correlationId)({\n        requestAuthority: request.authority,\n        requestAzureCloudOptions: request.azureCloudOptions,\n        requestExtraQueryParameters: request.extraQueryParameters,\n        account: request.account\n      });\n      return invokeAsync(handleResponseEAR, PerformanceEvents.HandleResponseEar, this.logger, this.performanceClient, request.correlationId)(request, serverParams, ApiId.acquireTokenRedirect, this.config, discoveredAuthority, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);\n    }\n    const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({\n      serverTelemetryManager,\n      requestAuthority: request.authority\n    });\n    return invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, request.correlationId)(request, serverParams, codeVerifier, ApiId.acquireTokenRedirect, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);\n  }\n  /**\r\n   * Redirects window to given URL.\r\n   * @param urlNavigate\r\n   * @param onRedirectNavigateRequest - onRedirectNavigate callback provided on the request\r\n   */\n  async initiateAuthRequest(requestUrl, onRedirectNavigateRequest) {\n    this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n    // Navigate if valid URL\n    if (requestUrl) {\n      this.logger.infoPii(\"RedirectHandler.initiateAuthRequest: Navigate to: \".concat(requestUrl));\n      const navigationOptions = {\n        apiId: ApiId.acquireTokenRedirect,\n        timeout: this.config.system.redirectNavigationTimeout,\n        noHistory: false\n      };\n      const onRedirectNavigate = onRedirectNavigateRequest || this.config.auth.onRedirectNavigate;\n      // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n      if (typeof onRedirectNavigate === \"function\") {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\");\n        const navigate = onRedirectNavigate(requestUrl);\n        // Returning false from onRedirectNavigate will stop navigation\n        if (navigate !== false) {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\");\n          await this.navigationClient.navigateExternal(requestUrl, navigationOptions);\n          return;\n        } else {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\");\n          return;\n        }\n      } else {\n        // Navigate window to request URL\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\");\n        await this.navigationClient.navigateExternal(requestUrl, navigationOptions);\n        return;\n      }\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.info(\"RedirectHandler.initiateAuthRequest: Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n  }\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param logoutRequest\r\n   */\n  async logout(logoutRequest) {\n    this.logger.verbose(\"logoutRedirect called\");\n    const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);\n    try {\n      this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n      // Clear cache on logout\n      await this.clearCacheOnLogout(this.correlationId, validLogoutRequest.account);\n      const navigationOptions = {\n        apiId: ApiId.logout,\n        timeout: this.config.system.redirectNavigationTimeout,\n        noHistory: false\n      };\n      const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({\n        serverTelemetryManager,\n        requestAuthority: logoutRequest && logoutRequest.authority,\n        requestExtraQueryParameters: logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.extraQueryParameters,\n        account: logoutRequest && logoutRequest.account || undefined\n      });\n      if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n        try {\n          authClient.authority.endSessionEndpoint;\n        } catch (_unused) {\n          var _validLogoutRequest$a;\n          if ((_validLogoutRequest$a = validLogoutRequest.account) !== null && _validLogoutRequest$a !== void 0 && _validLogoutRequest$a.homeAccountId) {\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n            return;\n          }\n        }\n      }\n      // Create logout string and navigate user window to logout.\n      const logoutUri = authClient.getLogoutUri(validLogoutRequest);\n      this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n      // Check if onRedirectNavigate is implemented, and invoke it if so\n      if (logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\") {\n        const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n        if (navigate !== false) {\n          this.logger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n          // Ensure interaction is in progress\n          if (!this.browserStorage.getInteractionInProgress()) {\n            this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);\n          }\n          await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n          return;\n        } else {\n          // Ensure interaction is not in progress\n          this.browserStorage.setInteractionInProgress(false);\n          this.logger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n        }\n      } else {\n        // Ensure interaction is in progress\n        if (!this.browserStorage.getInteractionInProgress()) {\n          this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);\n        }\n        await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n        return;\n      }\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);\n      this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n      throw e;\n    }\n    this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n  }\n  /**\r\n   * Use to get the redirectStartPage either from request or use current window\r\n   * @param requestStartPage\r\n   */\n  getRedirectStartPage(requestStartPage) {\n    const redirectStartPage = requestStartPage || window.location.href;\n    return UrlString.getAbsoluteUrl(redirectStartPage, getCurrentUri());\n  }\n}\nexport { RedirectClient };","map":{"version":3,"names":["getNavigationType","window","performance","getEntriesByType","undefined","navigationEntries","navigation","length","type","RedirectClient","StandardInteractionClient","constructor","config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","performanceClient","nativeStorageImpl","platformAuthHandler","correlationId","nativeStorage","acquireToken","request","validRequest","invokeAsync","initializeAuthorizationRequest","bind","PerformanceEvents","StandardInteractionClientInitializeAuthorizationRequest","InteractionType","Redirect","platformBroker","isPlatformAuthAllowed","platformAuthProvider","authenticationScheme","handleBackButton","event","persisted","verbose","browserStorage","resetRequestCache","emitEvent","EventType","RESTORE_FROM_BFCACHE","redirectStartPage","getRedirectStartPage","verbosePii","concat","setTemporaryCache","TemporaryCacheKeys","ORIGIN_URI","addEventListener","auth","protocolMode","ProtocolMode","EAR","executeEarFlow","executeCodeFlow","onRedirectNavigate","e","AuthError","setCorrelationId","removeEventListener","serverTelemetryManager","initializeServerTelemetryManager","ApiId","acquireTokenRedirect","pkceCodes","generatePkceCodes","GeneratePkceCodes","redirectRequest","_objectSpread","codeChallenge","challenge","cacheAuthorizeRequest","verifier","httpMethod","HttpMethod","POST","executeCodeFlowWithPost","authClient","createAuthCodeClient","StandardInteractionClientCreateAuthCodeClient","requestAuthority","authority","requestAzureCloudOptions","azureCloudOptions","requestExtraQueryParameters","extraQueryParameters","account","navigateUrl","getAuthCodeRequestUrl","GetAuthCodeUrl","initiateAuthRequest","cacheFailedRequest","discoveredAuthority","getDiscoveredAuthority","StandardInteractionClientGetDiscoveredAuthority","earJwk","generateEarKey","GenerateEarKey","form","getEARForm","document","submit","Promise","resolve","reject","setTimeout","createBrowserAuthError","timedOut","system","redirectNavigationTimeout","getCodeForm","handleRedirectPromise","hash","arguments","pkceVerifier","parentMeasurement","serverParams","responseString","getRedirectResponse","info","errorCode","loginRequestUrl","getTemporaryCache","Constants","EMPTY_STRING","loginRequestUrlNormalized","UrlUtils","normalizeUrlForComparison","currentUrlNormalized","location","href","navigateToLoginRequestUrl","indexOf","replaceHash","handleHashResult","handleResponse","isInIframe","allowRedirectInIframe","URL_HASH","navigationOptions","apiId","timeout","noHistory","processHashOnRedirect","homepage","getHomepage","warning","navigateInternal","userProvidedResponse","OIDCOptions","serverResponseType","ServerResponseType","QUERY","search","response","getDeserializedResponse","validateInteractionType","error","errorMessage","clearHash","cachedHash","removeItem","generateCacheKey","codeVerifier","state","noStateInHash","ear_jwe","handleResponseEAR","HandleResponseEar","handleResponseCode","HandleResponseCode","requestUrl","onRedirectNavigateRequest","infoPii","navigate","navigateExternal","emptyNavigateUri","logout","logoutRequest","validLogoutRequest","initializeLogoutRequest","LOGOUT_START","clearCacheOnLogout","OIDC","endSessionEndpoint","_unused","_validLogoutRequest$a","homeAccountId","LOGOUT_SUCCESS","logoutUri","getLogoutUri","getInteractionInProgress","setInteractionInProgress","INTERACTION_TYPE","SIGNOUT","LOGOUT_FAILURE","LOGOUT_END","requestStartPage","UrlString","getAbsoluteUrl","getCurrentUri"],"sources":["C:\\_Projects\\DGL_ToDo\\react_todo_dashboard2\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\RedirectClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodeClient,\n    UrlString,\n    AuthError,\n    ServerTelemetryManager,\n    Constants,\n    AuthorizeResponse,\n    ICrypto,\n    Logger,\n    IPerformanceClient,\n    PerformanceEvents,\n    ProtocolMode,\n    invokeAsync,\n    ServerResponseType,\n    UrlUtils,\n    InProgressPerformanceEvent,\n    CommonAuthorizationUrlRequest,\n    HttpMethod,\n} from \"@azure/msal-common/browser\";\nimport { StandardInteractionClient } from \"./StandardInteractionClient.js\";\nimport {\n    ApiId,\n    INTERACTION_TYPE,\n    InteractionType,\n    TemporaryCacheKeys,\n} from \"../utils/BrowserConstants.js\";\nimport * as BrowserUtils from \"../utils/BrowserUtils.js\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest.js\";\nimport { EventType } from \"../event/EventType.js\";\nimport { NavigationOptions } from \"../navigation/NavigationOptions.js\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError.js\";\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\nimport { BrowserConfiguration } from \"../config/Configuration.js\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager.js\";\nimport { EventHandler } from \"../event/EventHandler.js\";\nimport { INavigationClient } from \"../navigation/INavigationClient.js\";\nimport { EventError } from \"../event/EventMessage.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport * as ResponseHandler from \"../response/ResponseHandler.js\";\nimport * as Authorize from \"../protocol/Authorize.js\";\nimport { generatePkceCodes } from \"../crypto/PkceGenerator.js\";\nimport { isPlatformAuthAllowed } from \"../broker/nativeBroker/PlatformAuthProvider.js\";\nimport { generateEarKey } from \"../crypto/BrowserCrypto.js\";\nimport { IPlatformAuthHandler } from \"../broker/nativeBroker/IPlatformAuthHandler.js\";\n\nfunction getNavigationType(): NavigationTimingType | undefined {\n    if (\n        typeof window === \"undefined\" ||\n        typeof window.performance === \"undefined\" ||\n        typeof window.performance.getEntriesByType !== \"function\"\n    ) {\n        return undefined;\n    }\n\n    const navigationEntries = window.performance.getEntriesByType(\"navigation\");\n    const navigation = navigationEntries.length\n        ? (navigationEntries[0] as PerformanceNavigationTiming)\n        : undefined;\n    return navigation?.type;\n}\n\nexport class RedirectClient extends StandardInteractionClient {\n    protected nativeStorage: BrowserCacheManager;\n\n    constructor(\n        config: BrowserConfiguration,\n        storageImpl: BrowserCacheManager,\n        browserCrypto: ICrypto,\n        logger: Logger,\n        eventHandler: EventHandler,\n        navigationClient: INavigationClient,\n        performanceClient: IPerformanceClient,\n        nativeStorageImpl: BrowserCacheManager,\n        platformAuthHandler?: IPlatformAuthHandler,\n        correlationId?: string\n    ) {\n        super(\n            config,\n            storageImpl,\n            browserCrypto,\n            logger,\n            eventHandler,\n            navigationClient,\n            performanceClient,\n            platformAuthHandler,\n            correlationId\n        );\n        this.nativeStorage = nativeStorageImpl;\n    }\n\n    /**\n     * Redirects the page to the /authorize endpoint of the IDP\n     * @param request\n     */\n    async acquireToken(request: RedirectRequest): Promise<void> {\n        const validRequest = await invokeAsync(\n            this.initializeAuthorizationRequest.bind(this),\n            PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )(request, InteractionType.Redirect);\n\n        validRequest.platformBroker = isPlatformAuthAllowed(\n            this.config,\n            this.logger,\n            this.platformAuthProvider,\n            request.authenticationScheme\n        );\n\n        const handleBackButton = (event: PageTransitionEvent) => {\n            // Clear temporary cache if the back button is clicked during the redirect flow.\n            if (event.persisted) {\n                this.logger.verbose(\n                    \"Page was restored from back/forward cache. Clearing temporary cache.\"\n                );\n                this.browserStorage.resetRequestCache();\n                this.eventHandler.emitEvent(\n                    EventType.RESTORE_FROM_BFCACHE,\n                    InteractionType.Redirect\n                );\n            }\n        };\n\n        const redirectStartPage = this.getRedirectStartPage(\n            request.redirectStartPage\n        );\n        this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\n        // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n        this.browserStorage.setTemporaryCache(\n            TemporaryCacheKeys.ORIGIN_URI,\n            redirectStartPage,\n            true\n        );\n\n        // Clear temporary cache if the back button is clicked during the redirect flow.\n        window.addEventListener(\"pageshow\", handleBackButton);\n\n        try {\n            if (this.config.auth.protocolMode === ProtocolMode.EAR) {\n                await this.executeEarFlow(validRequest);\n            } else {\n                await this.executeCodeFlow(\n                    validRequest,\n                    request.onRedirectNavigate\n                );\n            }\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n            }\n            window.removeEventListener(\"pageshow\", handleBackButton);\n            throw e;\n        }\n    }\n\n    /**\n     * Executes auth code + PKCE flow\n     * @param request\n     * @returns\n     */\n    async executeCodeFlow(\n        request: CommonAuthorizationUrlRequest,\n        onRedirectNavigate?: (url: string) => boolean | void\n    ): Promise<void> {\n        const correlationId = request.correlationId;\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenRedirect\n        );\n\n        const pkceCodes = await invokeAsync(\n            generatePkceCodes,\n            PerformanceEvents.GeneratePkceCodes,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )(this.performanceClient, this.logger, correlationId);\n\n        const redirectRequest = {\n            ...request,\n            codeChallenge: pkceCodes.challenge,\n        };\n\n        this.browserStorage.cacheAuthorizeRequest(\n            redirectRequest,\n            pkceCodes.verifier\n        );\n\n        try {\n            if (redirectRequest.httpMethod === HttpMethod.POST) {\n                return await this.executeCodeFlowWithPost(redirectRequest);\n            } else {\n                // Initialize the client\n                const authClient: AuthorizationCodeClient = await invokeAsync(\n                    this.createAuthCodeClient.bind(this),\n                    PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n                    this.logger,\n                    this.performanceClient,\n                    this.correlationId\n                )({\n                    serverTelemetryManager,\n                    requestAuthority: redirectRequest.authority,\n                    requestAzureCloudOptions: redirectRequest.azureCloudOptions,\n                    requestExtraQueryParameters:\n                        redirectRequest.extraQueryParameters,\n                    account: redirectRequest.account,\n                });\n\n                // Create acquire token url.\n                const navigateUrl = await invokeAsync(\n                    Authorize.getAuthCodeRequestUrl,\n                    PerformanceEvents.GetAuthCodeUrl,\n                    this.logger,\n                    this.performanceClient,\n                    request.correlationId\n                )(\n                    this.config,\n                    authClient.authority,\n                    redirectRequest,\n                    this.logger,\n                    this.performanceClient\n                );\n                // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n                return await this.initiateAuthRequest(\n                    navigateUrl,\n                    onRedirectNavigate\n                );\n            }\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Executes EAR flow\n     * @param request\n     */\n    async executeEarFlow(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<void> {\n        const correlationId = request.correlationId;\n        // Get the frame handle for the silent request\n        const discoveredAuthority = await invokeAsync(\n            this.getDiscoveredAuthority.bind(this),\n            PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )({\n            requestAuthority: request.authority,\n            requestAzureCloudOptions: request.azureCloudOptions,\n            requestExtraQueryParameters: request.extraQueryParameters,\n            account: request.account,\n        });\n\n        const earJwk = await invokeAsync(\n            generateEarKey,\n            PerformanceEvents.GenerateEarKey,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )();\n        const redirectRequest = {\n            ...request,\n            earJwk: earJwk,\n        };\n        this.browserStorage.cacheAuthorizeRequest(redirectRequest);\n\n        const form = await Authorize.getEARForm(\n            document,\n            this.config,\n            discoveredAuthority,\n            redirectRequest,\n            this.logger,\n            this.performanceClient\n        );\n        form.submit();\n        return new Promise<void>((resolve, reject) => {\n            setTimeout(() => {\n                reject(\n                    createBrowserAuthError(\n                        BrowserAuthErrorCodes.timedOut,\n                        \"failed_to_redirect\"\n                    )\n                );\n            }, this.config.system.redirectNavigationTimeout);\n        });\n    }\n\n    /**\n     * Executes classic Authorization Code flow with a POST request.\n     * @param request\n     */\n    async executeCodeFlowWithPost(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<void> {\n        const correlationId = request.correlationId;\n        // Get the frame handle for the silent request\n        const discoveredAuthority = await invokeAsync(\n            this.getDiscoveredAuthority.bind(this),\n            PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )({\n            requestAuthority: request.authority,\n            requestAzureCloudOptions: request.azureCloudOptions,\n            requestExtraQueryParameters: request.extraQueryParameters,\n            account: request.account,\n        });\n\n        this.browserStorage.cacheAuthorizeRequest(request);\n\n        const form = await Authorize.getCodeForm(\n            document,\n            this.config,\n            discoveredAuthority,\n            request,\n            this.logger,\n            this.performanceClient\n        );\n\n        form.submit();\n        return new Promise<void>((resolve, reject) => {\n            setTimeout(() => {\n                reject(\n                    createBrowserAuthError(\n                        BrowserAuthErrorCodes.timedOut,\n                        \"failed_to_redirect\"\n                    )\n                );\n            }, this.config.system.redirectNavigationTimeout);\n        });\n    }\n\n    /**\n     * Checks if navigateToLoginRequestUrl is set, and:\n     * - if true, performs logic to cache and navigate\n     * - if false, handles hash string and parses response\n     * @param hash {string} url hash\n     * @param parentMeasurement {InProgressPerformanceEvent} parent measurement\n     */\n    async handleRedirectPromise(\n        hash: string = \"\",\n        request: CommonAuthorizationUrlRequest,\n        pkceVerifier: string,\n        parentMeasurement: InProgressPerformanceEvent\n    ): Promise<AuthenticationResult | null> {\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.handleRedirectPromise\n        );\n\n        try {\n            const [serverParams, responseString] = this.getRedirectResponse(\n                hash || \"\"\n            );\n            if (!serverParams) {\n                // Not a recognized server response hash or hash not associated with a redirect request\n                this.logger.info(\n                    \"handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.\"\n                );\n                this.browserStorage.resetRequestCache();\n\n                // Do not instrument \"no_server_response\" if user clicked back button\n                if (getNavigationType() !== \"back_forward\") {\n                    parentMeasurement.event.errorCode = \"no_server_response\";\n                } else {\n                    this.logger.verbose(\n                        \"Back navigation event detected. Muting no_server_response error\"\n                    );\n                }\n                return null;\n            }\n\n            // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n            const loginRequestUrl =\n                this.browserStorage.getTemporaryCache(\n                    TemporaryCacheKeys.ORIGIN_URI,\n                    true\n                ) || Constants.EMPTY_STRING;\n            const loginRequestUrlNormalized =\n                UrlUtils.normalizeUrlForComparison(loginRequestUrl);\n            const currentUrlNormalized = UrlUtils.normalizeUrlForComparison(\n                window.location.href\n            );\n\n            if (\n                loginRequestUrlNormalized === currentUrlNormalized &&\n                this.config.auth.navigateToLoginRequestUrl\n            ) {\n                // We are on the page we need to navigate to - handle hash\n                this.logger.verbose(\n                    \"Current page is loginRequestUrl, handling response\"\n                );\n\n                if (loginRequestUrl.indexOf(\"#\") > -1) {\n                    // Replace current hash with non-msal hash, if present\n                    BrowserUtils.replaceHash(loginRequestUrl);\n                }\n\n                const handleHashResult = await this.handleResponse(\n                    serverParams,\n                    request,\n                    pkceVerifier,\n                    serverTelemetryManager\n                );\n\n                return handleHashResult;\n            } else if (!this.config.auth.navigateToLoginRequestUrl) {\n                this.logger.verbose(\n                    \"NavigateToLoginRequestUrl set to false, handling response\"\n                );\n                return await this.handleResponse(\n                    serverParams,\n                    request,\n                    pkceVerifier,\n                    serverTelemetryManager\n                );\n            } else if (\n                !BrowserUtils.isInIframe() ||\n                this.config.system.allowRedirectInIframe\n            ) {\n                /*\n                 * Returned from authority using redirect - need to perform navigation before processing response\n                 * Cache the hash to be retrieved after the next redirect\n                 */\n                this.browserStorage.setTemporaryCache(\n                    TemporaryCacheKeys.URL_HASH,\n                    responseString,\n                    true\n                );\n                const navigationOptions: NavigationOptions = {\n                    apiId: ApiId.handleRedirectPromise,\n                    timeout: this.config.system.redirectNavigationTimeout,\n                    noHistory: true,\n                };\n\n                /**\n                 * Default behavior is to redirect to the start page and not process the hash now.\n                 * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\n                 */\n                let processHashOnRedirect: boolean = true;\n                if (!loginRequestUrl || loginRequestUrl === \"null\") {\n                    // Redirect to home page if login request url is null (real null or the string null)\n                    const homepage = BrowserUtils.getHomepage();\n                    // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n                    this.browserStorage.setTemporaryCache(\n                        TemporaryCacheKeys.ORIGIN_URI,\n                        homepage,\n                        true\n                    );\n                    this.logger.warning(\n                        \"Unable to get valid login request url from cache, redirecting to home page\"\n                    );\n                    processHashOnRedirect =\n                        await this.navigationClient.navigateInternal(\n                            homepage,\n                            navigationOptions\n                        );\n                } else {\n                    // Navigate to page that initiated the redirect request\n                    this.logger.verbose(\n                        `Navigating to loginRequestUrl: ${loginRequestUrl}`\n                    );\n                    processHashOnRedirect =\n                        await this.navigationClient.navigateInternal(\n                            loginRequestUrl,\n                            navigationOptions\n                        );\n                }\n\n                // If navigateInternal implementation returns false, handle the hash now\n                if (!processHashOnRedirect) {\n                    return await this.handleResponse(\n                        serverParams,\n                        request,\n                        pkceVerifier,\n                        serverTelemetryManager\n                    );\n                }\n            }\n\n            return null;\n        } catch (e) {\n            if (e instanceof AuthError) {\n                (e as AuthError).setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Gets the response hash for a redirect request\n     * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\n     * @param hash\n     */\n    protected getRedirectResponse(\n        userProvidedResponse: string\n    ): [AuthorizeResponse | null, string] {\n        this.logger.verbose(\"getRedirectResponseHash called\");\n        // Get current location hash from window or cache.\n        let responseString = userProvidedResponse;\n        if (!responseString) {\n            if (\n                this.config.auth.OIDCOptions.serverResponseType ===\n                ServerResponseType.QUERY\n            ) {\n                responseString = window.location.search;\n            } else {\n                responseString = window.location.hash;\n            }\n        }\n        let response = UrlUtils.getDeserializedResponse(responseString);\n\n        if (response) {\n            try {\n                ResponseHandler.validateInteractionType(\n                    response,\n                    this.browserCrypto,\n                    InteractionType.Redirect\n                );\n            } catch (e) {\n                if (e instanceof AuthError) {\n                    this.logger.error(\n                        `Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`\n                    );\n                }\n                return [null, \"\"];\n            }\n\n            BrowserUtils.clearHash(window);\n            this.logger.verbose(\n                \"Hash contains known properties, returning response hash\"\n            );\n            return [response, responseString];\n        }\n\n        const cachedHash = this.browserStorage.getTemporaryCache(\n            TemporaryCacheKeys.URL_HASH,\n            true\n        );\n        this.browserStorage.removeItem(\n            this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH)\n        );\n\n        if (cachedHash) {\n            response = UrlUtils.getDeserializedResponse(cachedHash);\n            if (response) {\n                this.logger.verbose(\n                    \"Hash does not contain known properties, returning cached hash\"\n                );\n                return [response, cachedHash];\n            }\n        }\n\n        return [null, \"\"];\n    }\n\n    /**\n     * Checks if hash exists and handles in window.\n     * @param hash\n     * @param state\n     */\n    protected async handleResponse(\n        serverParams: AuthorizeResponse,\n        request: CommonAuthorizationUrlRequest,\n        codeVerifier: string,\n        serverTelemetryManager: ServerTelemetryManager\n    ): Promise<AuthenticationResult> {\n        const state = serverParams.state;\n        if (!state) {\n            throw createBrowserAuthError(BrowserAuthErrorCodes.noStateInHash);\n        }\n\n        if (serverParams.ear_jwe) {\n            const discoveredAuthority = await invokeAsync(\n                this.getDiscoveredAuthority.bind(this),\n                PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )({\n                requestAuthority: request.authority,\n                requestAzureCloudOptions: request.azureCloudOptions,\n                requestExtraQueryParameters: request.extraQueryParameters,\n                account: request.account,\n            });\n            return invokeAsync(\n                Authorize.handleResponseEAR,\n                PerformanceEvents.HandleResponseEar,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )(\n                request,\n                serverParams,\n                ApiId.acquireTokenRedirect,\n                this.config,\n                discoveredAuthority,\n                this.browserStorage,\n                this.nativeStorage,\n                this.eventHandler,\n                this.logger,\n                this.performanceClient,\n                this.platformAuthProvider\n            );\n        }\n\n        const authClient = await invokeAsync(\n            this.createAuthCodeClient.bind(this),\n            PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )({ serverTelemetryManager, requestAuthority: request.authority });\n        return invokeAsync(\n            Authorize.handleResponseCode,\n            PerformanceEvents.HandleResponseCode,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            request,\n            serverParams,\n            codeVerifier,\n            ApiId.acquireTokenRedirect,\n            this.config,\n            authClient,\n            this.browserStorage,\n            this.nativeStorage,\n            this.eventHandler,\n            this.logger,\n            this.performanceClient,\n            this.platformAuthProvider\n        );\n    }\n\n    /**\n     * Redirects window to given URL.\n     * @param urlNavigate\n     * @param onRedirectNavigateRequest - onRedirectNavigate callback provided on the request\n     */\n    async initiateAuthRequest(\n        requestUrl: string,\n        onRedirectNavigateRequest?: (url: string) => boolean | void\n    ): Promise<void> {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n        // Navigate if valid URL\n        if (requestUrl) {\n            this.logger.infoPii(\n                `RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`\n            );\n            const navigationOptions: NavigationOptions = {\n                apiId: ApiId.acquireTokenRedirect,\n                timeout: this.config.system.redirectNavigationTimeout,\n                noHistory: false,\n            };\n\n            const onRedirectNavigate =\n                onRedirectNavigateRequest ||\n                this.config.auth.onRedirectNavigate;\n\n            // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n            if (typeof onRedirectNavigate === \"function\") {\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\"\n                );\n                const navigate = onRedirectNavigate(requestUrl);\n\n                // Returning false from onRedirectNavigate will stop navigation\n                if (navigate !== false) {\n                    this.logger.verbose(\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\"\n                    );\n                    await this.navigationClient.navigateExternal(\n                        requestUrl,\n                        navigationOptions\n                    );\n                    return;\n                } else {\n                    this.logger.verbose(\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\"\n                    );\n                    return;\n                }\n            } else {\n                // Navigate window to request URL\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\"\n                );\n                await this.navigationClient.navigateExternal(\n                    requestUrl,\n                    navigationOptions\n                );\n                return;\n            }\n        } else {\n            // Throw error if request URL is empty.\n            this.logger.info(\n                \"RedirectHandler.initiateAuthRequest: Navigate url is empty\"\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.emptyNavigateUri\n            );\n        }\n    }\n\n    /**\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param logoutRequest\n     */\n    async logout(logoutRequest?: EndSessionRequest): Promise<void> {\n        this.logger.verbose(\"logoutRedirect called\");\n        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.logout\n        );\n\n        try {\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_START,\n                InteractionType.Redirect,\n                logoutRequest\n            );\n\n            // Clear cache on logout\n            await this.clearCacheOnLogout(\n                this.correlationId,\n                validLogoutRequest.account\n            );\n\n            const navigationOptions: NavigationOptions = {\n                apiId: ApiId.logout,\n                timeout: this.config.system.redirectNavigationTimeout,\n                noHistory: false,\n            };\n\n            const authClient = await invokeAsync(\n                this.createAuthCodeClient.bind(this),\n                PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n                this.logger,\n                this.performanceClient,\n                this.correlationId\n            )({\n                serverTelemetryManager,\n                requestAuthority: logoutRequest && logoutRequest.authority,\n                requestExtraQueryParameters:\n                    logoutRequest?.extraQueryParameters,\n                account: (logoutRequest && logoutRequest.account) || undefined,\n            });\n\n            if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n                try {\n                    authClient.authority.endSessionEndpoint;\n                } catch {\n                    if (validLogoutRequest.account?.homeAccountId) {\n                        this.eventHandler.emitEvent(\n                            EventType.LOGOUT_SUCCESS,\n                            InteractionType.Redirect,\n                            validLogoutRequest\n                        );\n\n                        return;\n                    }\n                }\n            }\n\n            // Create logout string and navigate user window to logout.\n            const logoutUri: string =\n                authClient.getLogoutUri(validLogoutRequest);\n\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_SUCCESS,\n                InteractionType.Redirect,\n                validLogoutRequest\n            );\n            // Check if onRedirectNavigate is implemented, and invoke it if so\n            if (\n                logoutRequest &&\n                typeof logoutRequest.onRedirectNavigate === \"function\"\n            ) {\n                const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n\n                if (navigate !== false) {\n                    this.logger.verbose(\n                        \"Logout onRedirectNavigate did not return false, navigating\"\n                    );\n                    // Ensure interaction is in progress\n                    if (!this.browserStorage.getInteractionInProgress()) {\n                        this.browserStorage.setInteractionInProgress(\n                            true,\n                            INTERACTION_TYPE.SIGNOUT\n                        );\n                    }\n                    await this.navigationClient.navigateExternal(\n                        logoutUri,\n                        navigationOptions\n                    );\n                    return;\n                } else {\n                    // Ensure interaction is not in progress\n                    this.browserStorage.setInteractionInProgress(false);\n                    this.logger.verbose(\n                        \"Logout onRedirectNavigate returned false, stopping navigation\"\n                    );\n                }\n            } else {\n                // Ensure interaction is in progress\n                if (!this.browserStorage.getInteractionInProgress()) {\n                    this.browserStorage.setInteractionInProgress(\n                        true,\n                        INTERACTION_TYPE.SIGNOUT\n                    );\n                }\n                await this.navigationClient.navigateExternal(\n                    logoutUri,\n                    navigationOptions\n                );\n                return;\n            }\n        } catch (e) {\n            if (e instanceof AuthError) {\n                (e as AuthError).setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_FAILURE,\n                InteractionType.Redirect,\n                null,\n                e as EventError\n            );\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_END,\n                InteractionType.Redirect\n            );\n            throw e;\n        }\n\n        this.eventHandler.emitEvent(\n            EventType.LOGOUT_END,\n            InteractionType.Redirect\n        );\n    }\n\n    /**\n     * Use to get the redirectStartPage either from request or use current window\n     * @param requestStartPage\n     */\n    protected getRedirectStartPage(requestStartPage?: string): string {\n        const redirectStartPage = requestStartPage || window.location.href;\n        return UrlString.getAbsoluteUrl(\n            redirectStartPage,\n            BrowserUtils.getCurrentUri()\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}