{"ast":null,"code":"/*! @azure/msal-common v15.13.0 2025-09-24 */\n'use strict';\n\nimport _objectSpread from \"C:/_Projects/DGL_ToDo/react_todo_dashboard2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isOidcProtocolMode } from '../config/ClientConfiguration.mjs';\nimport { BaseClient } from './BaseClient.mjs';\nimport { addClientId, addRedirectUri, addScopes, addGrantType, addClientInfo, addLibraryInfo, addApplicationTelemetry, addThrottling, addServerTelemetry, addRefreshToken, addClientSecret, addClientAssertion, addClientAssertionType, addPopToken, addSshJwk, addClaims, addCcsUpn, addCcsOid, addBrokerParameters, addExtraQueryParameters, instrumentBrokerParams } from '../request/RequestParameterBuilder.mjs';\nimport { mapToQueryString } from '../utils/UrlUtils.mjs';\nimport { AuthenticationScheme, HeaderNames, Errors, GrantType } from '../utils/Constants.mjs';\nimport { CLIENT_ID } from '../constants/AADServerParamKeys.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { nowSeconds, isTokenExpired } from '../utils/TimeUtils.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { CcsCredentialType } from '../account/CcsCredential.mjs';\nimport { buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { createInteractionRequiredAuthError, InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync, invoke } from '../utils/FunctionWrappers.mjs';\nimport { getClientAssertion } from '../utils/ClientAssertionUtils.mjs';\nimport { getRequestThumbprint } from '../network/RequestThumbprint.mjs';\nimport { badToken, noTokensFound, refreshTokenExpired } from '../error/InteractionRequiredAuthErrorCodes.mjs';\nimport { tokenRequestEmpty, missingSshJwk } from '../error/ClientConfigurationErrorCodes.mjs';\nimport { noAccountInSilentRequest } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300; // 5 Minutes\n/**\r\n * OAuth2.0 refresh token client\r\n * @internal\r\n */\nclass RefreshTokenClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n  }\n  async acquireToken(request) {\n    var _this$performanceClie, _response$headers;\n    (_this$performanceClie = this.performanceClient) === null || _this$performanceClie === void 0 || _this$performanceClie.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);\n    const reqTimestamp = nowSeconds();\n    const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);\n    // Retrieve requestId from response headers\n    const requestId = (_response$headers = response.headers) === null || _response$headers === void 0 ? void 0 : _response$headers[HeaderNames.X_MS_REQUEST_ID];\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\n    responseHandler.validateTokenResponse(response.body);\n    return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, undefined, undefined, true, request.forceCache, requestId);\n  }\n  /**\r\n   * Gets cached refresh token and attaches to request, then calls acquireToken API\r\n   * @param request\r\n   */\n  async acquireTokenByRefreshToken(request) {\n    var _this$performanceClie2;\n    // Cannot renew token if no request object is given.\n    if (!request) {\n      throw createClientConfigurationError(tokenRequestEmpty);\n    }\n    (_this$performanceClie2 = this.performanceClient) === null || _this$performanceClie2 === void 0 || _this$performanceClie2.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);\n    // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n    if (!request.account) {\n      throw createClientAuthError(noAccountInSilentRequest);\n    }\n    // try checking if FOCI is enabled for the given application\n    const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);\n    // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest\n    if (isFOCI) {\n      try {\n        return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);\n      } catch (e) {\n        const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;\n        const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;\n        // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)\n        if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {\n          return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);\n          // throw in all other cases\n        } else {\n          throw e;\n        }\n      }\n    }\n    // fall back to application refresh token acquisition\n    return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);\n  }\n  /**\r\n   * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached\r\n   * @param request\r\n   */\n  async acquireTokenWithCachedRefreshToken(request, foci) {\n    var _this$performanceClie3;\n    (_this$performanceClie3 = this.performanceClient) === null || _this$performanceClie3 === void 0 || _this$performanceClie3.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);\n    // fetches family RT or application RT based on FOCI value\n    const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, request.correlationId, undefined, this.performanceClient);\n    if (!refreshToken) {\n      throw createInteractionRequiredAuthError(noTokensFound);\n    }\n    if (refreshToken.expiresOn && isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {\n      var _this$performanceClie4;\n      (_this$performanceClie4 = this.performanceClient) === null || _this$performanceClie4 === void 0 || _this$performanceClie4.addFields({\n        rtExpiresOnMs: Number(refreshToken.expiresOn)\n      }, request.correlationId);\n      throw createInteractionRequiredAuthError(refreshTokenExpired);\n    }\n    // attach cached RT size to the current measurement\n    const refreshTokenRequest = _objectSpread(_objectSpread({}, request), {}, {\n      refreshToken: refreshToken.secret,\n      authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,\n      ccsCredential: {\n        credential: request.account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      }\n    });\n    try {\n      return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);\n    } catch (e) {\n      if (e instanceof InteractionRequiredAuthError) {\n        var _this$performanceClie5;\n        (_this$performanceClie5 = this.performanceClient) === null || _this$performanceClie5 === void 0 || _this$performanceClie5.addFields({\n          rtExpiresOnMs: Number(refreshToken.expiresOn)\n        }, request.correlationId);\n        if (e.subError === badToken) {\n          // Remove bad refresh token from cache\n          this.logger.verbose(\"acquireTokenWithRefreshToken: bad refresh token, removing from cache\");\n          const badRefreshTokenKey = this.cacheManager.generateCredentialKey(refreshToken);\n          this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);\n        }\n      }\n      throw e;\n    }\n  }\n  /**\r\n   * Constructs the network message and makes a NW call to the underlying secure token service\r\n   * @param request\r\n   * @param authority\r\n   */\n  async executeTokenRequest(request, authority) {\n    var _this$performanceClie6;\n    (_this$performanceClie6 = this.performanceClient) === null || _this$performanceClie6 === void 0 || _this$performanceClie6.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);\n    const queryParametersString = this.createTokenQueryParameters(request);\n    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n    const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);\n    const headers = this.createTokenRequestHeaders(request.ccsCredential);\n    const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);\n    return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);\n  }\n  /**\r\n   * Helper function to create the token request body\r\n   * @param request\r\n   */\n  async createTokenRequestBody(request) {\n    var _this$performanceClie7, _request$tokenBodyPar, _this$config$authOpti;\n    (_this$performanceClie7 = this.performanceClient) === null || _this$performanceClie7 === void 0 || _this$performanceClie7.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);\n    const parameters = new Map();\n    addClientId(parameters, request.embeddedClientId || ((_request$tokenBodyPar = request.tokenBodyParameters) === null || _request$tokenBodyPar === void 0 ? void 0 : _request$tokenBodyPar[CLIENT_ID]) || this.config.authOptions.clientId);\n    if (request.redirectUri) {\n      addRedirectUri(parameters, request.redirectUri);\n    }\n    addScopes(parameters, request.scopes, true, (_this$config$authOpti = this.config.authOptions.authority.options.OIDCOptions) === null || _this$config$authOpti === void 0 ? void 0 : _this$config$authOpti.defaultScopes);\n    addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);\n    addClientInfo(parameters);\n    addLibraryInfo(parameters, this.config.libraryInfo);\n    addApplicationTelemetry(parameters, this.config.telemetry.application);\n    addThrottling(parameters);\n    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n      addServerTelemetry(parameters, this.serverTelemetryManager);\n    }\n    addRefreshToken(parameters, request.refreshToken);\n    if (this.config.clientCredentials.clientSecret) {\n      addClientSecret(parameters, this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      const clientAssertion = this.config.clientCredentials.clientAssertion;\n      addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\n      addClientAssertionType(parameters, clientAssertion.assertionType);\n    }\n    if (request.authenticationScheme === AuthenticationScheme.POP) {\n      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n      let reqCnfData;\n      if (!request.popKid) {\n        const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n        reqCnfData = generatedReqCnfData.reqCnfString;\n      } else {\n        reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n      }\n      // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n      addPopToken(parameters, reqCnfData);\n    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n      if (request.sshJwk) {\n        addSshJwk(parameters, request.sshJwk);\n      } else {\n        throw createClientConfigurationError(missingSshJwk);\n      }\n    }\n    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\n    }\n    if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {\n      switch (request.ccsCredential.type) {\n        case CcsCredentialType.HOME_ACCOUNT_ID:\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);\n            addCcsOid(parameters, clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n          break;\n        case CcsCredentialType.UPN:\n          addCcsUpn(parameters, request.ccsCredential.credential);\n          break;\n      }\n    }\n    if (request.embeddedClientId) {\n      addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);\n    }\n    if (request.tokenBodyParameters) {\n      addExtraQueryParameters(parameters, request.tokenBodyParameters);\n    }\n    instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);\n    return mapToQueryString(parameters);\n  }\n}\nexport { RefreshTokenClient };","map":{"version":3,"names":["DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS","RefreshTokenClient","BaseClient","constructor","configuration","performanceClient","acquireToken","request","_this$performanceClie","_response$headers","addQueueMeasurement","PerformanceEvents","RefreshTokenClientAcquireToken","correlationId","reqTimestamp","nowSeconds","response","invokeAsync","executeTokenRequest","bind","RefreshTokenClientExecuteTokenRequest","logger","authority","requestId","headers","HeaderNames","X_MS_REQUEST_ID","responseHandler","ResponseHandler","config","authOptions","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","HandleServerTokenResponse","undefined","forceCache","acquireTokenByRefreshToken","_this$performanceClie2","createClientConfigurationError","tokenRequestEmpty","RefreshTokenClientAcquireTokenByRefreshToken","account","createClientAuthError","noAccountInSilentRequest","isFOCI","isAppMetadataFOCI","environment","acquireTokenWithCachedRefreshToken","RefreshTokenClientAcquireTokenWithCachedRefreshToken","e","noFamilyRTInCache","InteractionRequiredAuthError","errorCode","noTokensFound","clientMismatchErrorWithFamilyRT","ServerError","Errors","INVALID_GRANT_ERROR","subError","CLIENT_MISMATCH_ERROR","foci","_this$performanceClie3","refreshToken","invoke","getRefreshToken","CacheManagerGetRefreshToken","createInteractionRequiredAuthError","expiresOn","isTokenExpired","refreshTokenExpirationOffsetSeconds","_this$performanceClie4","addFields","rtExpiresOnMs","Number","refreshTokenExpired","refreshTokenRequest","_objectSpread","secret","authenticationScheme","AuthenticationScheme","BEARER","ccsCredential","credential","homeAccountId","type","CcsCredentialType","HOME_ACCOUNT_ID","_this$performanceClie5","badToken","verbose","badRefreshTokenKey","generateCredentialKey","removeRefreshToken","_this$performanceClie6","queryParametersString","createTokenQueryParameters","endpoint","UrlString","appendQueryString","tokenEndpoint","requestBody","createTokenRequestBody","RefreshTokenClientCreateTokenRequestBody","createTokenRequestHeaders","thumbprint","getRequestThumbprint","executePostToTokenEndpoint","RefreshTokenClientExecutePostToTokenEndpoint","_this$performanceClie7","_request$tokenBodyPar","_this$config$authOpti","parameters","Map","addClientId","embeddedClientId","tokenBodyParameters","CLIENT_ID","redirectUri","addRedirectUri","addScopes","scopes","options","OIDCOptions","defaultScopes","addGrantType","GrantType","REFRESH_TOKEN_GRANT","addClientInfo","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","isOidcProtocolMode","addServerTelemetry","addRefreshToken","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","getClientAssertion","assertion","resourceRequestUri","addClientAssertionType","assertionType","POP","popTokenGenerator","PopTokenGenerator","reqCnfData","popKid","generatedReqCnfData","generateCnf","PopTokenGenerateCnf","reqCnfString","encodeKid","addPopToken","SSH","sshJwk","addSshJwk","missingSshJwk","StringUtils","isEmptyObj","claims","clientCapabilities","length","addClaims","systemOptions","preventCorsPreflight","clientInfo","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","addBrokerParameters","addExtraQueryParameters","instrumentBrokerParams","mapToQueryString"],"sources":["C:\\_Projects\\DGL_ToDo\\react_todo_dashboard2\\node_modules\\@azure\\msal-common\\src\\client\\RefreshTokenClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ClientConfiguration,\n    isOidcProtocolMode,\n} from \"../config/ClientConfiguration.js\";\nimport { BaseClient } from \"./BaseClient.js\";\nimport { CommonRefreshTokenRequest } from \"../request/CommonRefreshTokenRequest.js\";\nimport { Authority } from \"../authority/Authority.js\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse.js\";\nimport * as RequestParameterBuilder from \"../request/RequestParameterBuilder.js\";\nimport * as UrlUtils from \"../utils/UrlUtils.js\";\nimport {\n    GrantType,\n    AuthenticationScheme,\n    Errors,\n    HeaderNames,\n} from \"../utils/Constants.js\";\nimport * as AADServerParamKeys from \"../constants/AADServerParamKeys.js\";\nimport { ResponseHandler } from \"../response/ResponseHandler.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator.js\";\nimport { StringUtils } from \"../utils/StringUtils.js\";\nimport { NetworkResponse } from \"../network/NetworkResponse.js\";\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest.js\";\nimport {\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n} from \"../error/ClientConfigurationError.js\";\nimport {\n    createClientAuthError,\n    ClientAuthErrorCodes,\n} from \"../error/ClientAuthError.js\";\nimport { ServerError } from \"../error/ServerError.js\";\nimport * as TimeUtils from \"../utils/TimeUtils.js\";\nimport { UrlString } from \"../url/UrlString.js\";\nimport { CcsCredentialType } from \"../account/CcsCredential.js\";\nimport { buildClientInfoFromHomeAccountId } from \"../account/ClientInfo.js\";\nimport {\n    InteractionRequiredAuthError,\n    InteractionRequiredAuthErrorCodes,\n    createInteractionRequiredAuthError,\n} from \"../error/InteractionRequiredAuthError.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { invoke, invokeAsync } from \"../utils/FunctionWrappers.js\";\nimport { ClientAssertion } from \"../account/ClientCredentials.js\";\nimport { getClientAssertion } from \"../utils/ClientAssertionUtils.js\";\nimport { getRequestThumbprint } from \"../network/RequestThumbprint.js\";\n\nconst DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300; // 5 Minutes\n\n/**\n * OAuth2.0 refresh token client\n * @internal\n */\nexport class RefreshTokenClient extends BaseClient {\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n    }\n    public async acquireToken(\n        request: CommonRefreshTokenRequest\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireToken,\n            request.correlationId\n        );\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await invokeAsync(\n            this.executeTokenRequest.bind(this),\n            PerformanceEvents.RefreshTokenClientExecuteTokenRequest,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request, this.authority);\n\n        // Retrieve requestId from response headers\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n        responseHandler.validateTokenResponse(response.body);\n\n        return invokeAsync(\n            responseHandler.handleServerTokenResponse.bind(responseHandler),\n            PerformanceEvents.HandleServerTokenResponse,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request,\n            undefined,\n            undefined,\n            true,\n            request.forceCache,\n            requestId\n        );\n    }\n\n    /**\n     * Gets cached refresh token and attaches to request, then calls acquireToken API\n     * @param request\n     */\n    public async acquireTokenByRefreshToken(\n        request: CommonSilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        // Cannot renew token if no request object is given.\n        if (!request) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.tokenRequestEmpty\n            );\n        }\n\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,\n            request.correlationId\n        );\n\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n        if (!request.account) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.noAccountInSilentRequest\n            );\n        }\n\n        // try checking if FOCI is enabled for the given application\n        const isFOCI = this.cacheManager.isAppMetadataFOCI(\n            request.account.environment\n        );\n\n        // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest\n        if (isFOCI) {\n            try {\n                return await invokeAsync(\n                    this.acquireTokenWithCachedRefreshToken.bind(this),\n                    PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n                    this.logger,\n                    this.performanceClient,\n                    request.correlationId\n                )(request, true);\n            } catch (e) {\n                const noFamilyRTInCache =\n                    e instanceof InteractionRequiredAuthError &&\n                    e.errorCode ===\n                        InteractionRequiredAuthErrorCodes.noTokensFound;\n                const clientMismatchErrorWithFamilyRT =\n                    e instanceof ServerError &&\n                    e.errorCode === Errors.INVALID_GRANT_ERROR &&\n                    e.subError === Errors.CLIENT_MISMATCH_ERROR;\n\n                // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)\n                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {\n                    return invokeAsync(\n                        this.acquireTokenWithCachedRefreshToken.bind(this),\n                        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n                        this.logger,\n                        this.performanceClient,\n                        request.correlationId\n                    )(request, false);\n                    // throw in all other cases\n                } else {\n                    throw e;\n                }\n            }\n        }\n        // fall back to application refresh token acquisition\n        return invokeAsync(\n            this.acquireTokenWithCachedRefreshToken.bind(this),\n            PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request, false);\n    }\n\n    /**\n     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached\n     * @param request\n     */\n    private async acquireTokenWithCachedRefreshToken(\n        request: CommonSilentFlowRequest,\n        foci: boolean\n    ) {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n            request.correlationId\n        );\n\n        // fetches family RT or application RT based on FOCI value\n        const refreshToken = invoke(\n            this.cacheManager.getRefreshToken.bind(this.cacheManager),\n            PerformanceEvents.CacheManagerGetRefreshToken,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            request.account,\n            foci,\n            request.correlationId,\n            undefined,\n            this.performanceClient\n        );\n\n        if (!refreshToken) {\n            throw createInteractionRequiredAuthError(\n                InteractionRequiredAuthErrorCodes.noTokensFound\n            );\n        }\n\n        if (\n            refreshToken.expiresOn &&\n            TimeUtils.isTokenExpired(\n                refreshToken.expiresOn,\n                request.refreshTokenExpirationOffsetSeconds ||\n                    DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS\n            )\n        ) {\n            this.performanceClient?.addFields(\n                { rtExpiresOnMs: Number(refreshToken.expiresOn) },\n                request.correlationId\n            );\n            throw createInteractionRequiredAuthError(\n                InteractionRequiredAuthErrorCodes.refreshTokenExpired\n            );\n        }\n        // attach cached RT size to the current measurement\n\n        const refreshTokenRequest: CommonRefreshTokenRequest = {\n            ...request,\n            refreshToken: refreshToken.secret,\n            authenticationScheme:\n                request.authenticationScheme || AuthenticationScheme.BEARER,\n            ccsCredential: {\n                credential: request.account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            },\n        };\n\n        try {\n            return await invokeAsync(\n                this.acquireToken.bind(this),\n                PerformanceEvents.RefreshTokenClientAcquireToken,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )(refreshTokenRequest);\n        } catch (e) {\n            if (e instanceof InteractionRequiredAuthError) {\n                this.performanceClient?.addFields(\n                    { rtExpiresOnMs: Number(refreshToken.expiresOn) },\n                    request.correlationId\n                );\n\n                if (e.subError === InteractionRequiredAuthErrorCodes.badToken) {\n                    // Remove bad refresh token from cache\n                    this.logger.verbose(\n                        \"acquireTokenWithRefreshToken: bad refresh token, removing from cache\"\n                    );\n                    const badRefreshTokenKey =\n                        this.cacheManager.generateCredentialKey(refreshToken);\n                    this.cacheManager.removeRefreshToken(\n                        badRefreshTokenKey,\n                        request.correlationId\n                    );\n                }\n            }\n\n            throw e;\n        }\n    }\n\n    /**\n     * Constructs the network message and makes a NW call to the underlying secure token service\n     * @param request\n     * @param authority\n     */\n    private async executeTokenRequest(\n        request: CommonRefreshTokenRequest,\n        authority: Authority\n    ): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientExecuteTokenRequest,\n            request.correlationId\n        );\n\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n\n        const requestBody = await invokeAsync(\n            this.createTokenRequestBody.bind(this),\n            PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n        const headers: Record<string, string> = this.createTokenRequestHeaders(\n            request.ccsCredential\n        );\n\n        const thumbprint = getRequestThumbprint(\n            this.config.authOptions.clientId,\n            request\n        );\n\n        return invokeAsync(\n            this.executePostToTokenEndpoint.bind(this),\n            PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId,\n            PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint\n        );\n    }\n\n    /**\n     * Helper function to create the token request body\n     * @param request\n     */\n    private async createTokenRequestBody(\n        request: CommonRefreshTokenRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,\n            request.correlationId\n        );\n\n        const parameters = new Map<string, string>();\n\n        RequestParameterBuilder.addClientId(\n            parameters,\n            request.embeddedClientId ||\n                request.tokenBodyParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        if (request.redirectUri) {\n            RequestParameterBuilder.addRedirectUri(\n                parameters,\n                request.redirectUri\n            );\n        }\n\n        RequestParameterBuilder.addScopes(\n            parameters,\n            request.scopes,\n            true,\n            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes\n        );\n\n        RequestParameterBuilder.addGrantType(\n            parameters,\n            GrantType.REFRESH_TOKEN_GRANT\n        );\n\n        RequestParameterBuilder.addClientInfo(parameters);\n\n        RequestParameterBuilder.addLibraryInfo(\n            parameters,\n            this.config.libraryInfo\n        );\n        RequestParameterBuilder.addApplicationTelemetry(\n            parameters,\n            this.config.telemetry.application\n        );\n        RequestParameterBuilder.addThrottling(parameters);\n\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n            RequestParameterBuilder.addServerTelemetry(\n                parameters,\n                this.serverTelemetryManager\n            );\n        }\n\n        RequestParameterBuilder.addRefreshToken(\n            parameters,\n            request.refreshToken\n        );\n\n        if (this.config.clientCredentials.clientSecret) {\n            RequestParameterBuilder.addClientSecret(\n                parameters,\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion: ClientAssertion =\n                this.config.clientCredentials.clientAssertion;\n\n            RequestParameterBuilder.addClientAssertion(\n                parameters,\n                await getClientAssertion(\n                    clientAssertion.assertion,\n                    this.config.authOptions.clientId,\n                    request.resourceRequestUri\n                )\n            );\n            RequestParameterBuilder.addClientAssertionType(\n                parameters,\n                clientAssertion.assertionType\n            );\n        }\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(\n                this.cryptoUtils,\n                this.performanceClient\n            );\n\n            let reqCnfData;\n            if (!request.popKid) {\n                const generatedReqCnfData = await invokeAsync(\n                    popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                    PerformanceEvents.PopTokenGenerateCnf,\n                    this.logger,\n                    this.performanceClient,\n                    request.correlationId\n                )(request, this.logger);\n\n                reqCnfData = generatedReqCnfData.reqCnfString;\n            } else {\n                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n            }\n\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            RequestParameterBuilder.addPopToken(parameters, reqCnfData);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if (request.sshJwk) {\n                RequestParameterBuilder.addSshJwk(parameters, request.sshJwk);\n            } else {\n                throw createClientConfigurationError(\n                    ClientConfigurationErrorCodes.missingSshJwk\n                );\n            }\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            RequestParameterBuilder.addClaims(\n                parameters,\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        if (\n            this.config.systemOptions.preventCorsPreflight &&\n            request.ccsCredential\n        ) {\n            switch (request.ccsCredential.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.ccsCredential.credential\n                        );\n                        RequestParameterBuilder.addCcsOid(\n                            parameters,\n                            clientInfo\n                        );\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"Could not parse home account ID for CCS Header: \" +\n                                e\n                        );\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    RequestParameterBuilder.addCcsUpn(\n                        parameters,\n                        request.ccsCredential.credential\n                    );\n                    break;\n            }\n        }\n\n        if (request.embeddedClientId) {\n            RequestParameterBuilder.addBrokerParameters(\n                parameters,\n                this.config.authOptions.clientId,\n                this.config.authOptions.redirectUri\n            );\n        }\n\n        if (request.tokenBodyParameters) {\n            RequestParameterBuilder.addExtraQueryParameters(\n                parameters,\n                request.tokenBodyParameters\n            );\n        }\n\n        RequestParameterBuilder.instrumentBrokerParams(\n            parameters,\n            request.correlationId,\n            this.performanceClient\n        );\n        return UrlUtils.mapToQueryString(parameters);\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAGG;AAkDH,MAAMA,+CAA+C,GAAG,GAAG,CAAC;AAE5D;;;AAGG;AACG,MAAOC,kBAAmB,SAAQC,UAAU;EAC9CC,WACIA,CAAAC,aAAkC,EAClCC,iBAAsC;IAEtC,KAAK,CAACD,aAAa,EAAEC,iBAAiB,CAAC;;EAEpC,MAAMC,YAAYA,CACrBC,OAAkC;IAAA,IAAAC,qBAAA,EAAAC,iBAAA;IAElC,CAAAD,qBAAA,OAAI,CAACH,iBAAiB,cAAAG,qBAAA,eAAtBA,qBAAA,CAAwBE,mBAAmB,CACvCC,iBAAiB,CAACC,8BAA8B,EAChDL,OAAO,CAACM,aAAa,CACxB;IAED,MAAMC,YAAY,GAAGC,UAAoB,EAAE;IAC3C,MAAMC,QAAQ,GAAG,MAAMC,WAAW,CAC9B,IAAI,CAACC,mBAAmB,CAACC,IAAI,CAAC,IAAI,CAAC,EACnCR,iBAAiB,CAACS,qCAAqC,EACvD,IAAI,CAACC,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CAACN,OAAO,EAAE,IAAI,CAACe,SAAS,CAAC;;IAG1B,MAAMC,SAAS,IAAAd,iBAAA,GAAGO,QAAQ,CAACQ,OAAO,cAAAf,iBAAA,uBAAhBA,iBAAA,CAAmBgB,WAAW,CAACC,eAAe,CAAC;IACjE,MAAMC,eAAe,GAAG,IAAIC,eAAe,CACvC,IAAI,CAACC,MAAM,CAACC,WAAW,CAACC,QAAQ,EAChC,IAAI,CAACC,YAAY,EACjB,IAAI,CAACC,WAAW,EAChB,IAAI,CAACZ,MAAM,EACX,IAAI,CAACQ,MAAM,CAACK,iBAAiB,EAC7B,IAAI,CAACL,MAAM,CAACM,iBAAiB,CAChC;IACDR,eAAe,CAACS,qBAAqB,CAACpB,QAAQ,CAACqB,IAAI,CAAC;IAEpD,OAAOpB,WAAW,CACdU,eAAe,CAACW,yBAAyB,CAACnB,IAAI,CAACQ,eAAe,CAAC,EAC/DhB,iBAAiB,CAAC4B,yBAAyB,EAC3C,IAAI,CAAClB,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CACGG,QAAQ,CAACqB,IAAI,EACb,IAAI,CAACf,SAAS,EACdR,YAAY,EACZP,OAAO,EACPiC,SAAS,EACTA,SAAS,EACT,IAAI,EACJjC,OAAO,CAACkC,UAAU,EAClBlB,SAAS,CACZ;;EAGL;;;AAGG;EACI,MAAMmB,0BAA0BA,CACnCnC,OAAgC;IAAA,IAAAoC,sBAAA;;IAGhC,IAAI,CAACpC,OAAO,EAAE;MACV,MAAMqC,8BAA8B,CAChCC,iBAA+C,CAClD;IACJ;IAED,CAAAF,sBAAA,OAAI,CAACtC,iBAAiB,cAAAsC,sBAAA,eAAtBA,sBAAA,CAAwBjC,mBAAmB,CACvCC,iBAAiB,CAACmC,4CAA4C,EAC9DvC,OAAO,CAACM,aAAa,CACxB;;IAGD,IAAI,CAACN,OAAO,CAACwC,OAAO,EAAE;MAClB,MAAMC,qBAAqB,CACvBC,wBAA6C,CAChD;IACJ;;IAGD,MAAMC,MAAM,GAAG,IAAI,CAAClB,YAAY,CAACmB,iBAAiB,CAC9C5C,OAAO,CAACwC,OAAO,CAACK,WAAW,CAC9B;;IAGD,IAAIF,MAAM,EAAE;MACR,IAAI;QACA,OAAO,MAAMjC,WAAW,CACpB,IAAI,CAACoC,kCAAkC,CAAClC,IAAI,CAAC,IAAI,CAAC,EAClDR,iBAAiB,CAAC2C,oDAAoD,EACtE,IAAI,CAACjC,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CAACN,OAAO,EAAE,IAAI,CAAC;MACnB,EAAC,OAAOgD,CAAC,EAAE;QACR,MAAMC,iBAAiB,GACnBD,CAAC,YAAYE,4BAA4B,IACzCF,CAAC,CAACG,SAAS,KACPC,aAA+C;QACvD,MAAMC,+BAA+B,GACjCL,CAAC,YAAYM,WAAW,IACxBN,CAAC,CAACG,SAAS,KAAKI,MAAM,CAACC,mBAAmB,IAC1CR,CAAC,CAACS,QAAQ,KAAKF,MAAM,CAACG,qBAAqB;;QAG/C,IAAIT,iBAAiB,IAAII,+BAA+B,EAAE;UACtD,OAAO3C,WAAW,CACd,IAAI,CAACoC,kCAAkC,CAAClC,IAAI,CAAC,IAAI,CAAC,EAClDR,iBAAiB,CAAC2C,oDAAoD,EACtE,IAAI,CAACjC,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CAACN,OAAO,EAAE,KAAK,CAAC;;QAEpB,OAAM;UACH,MAAMgD,CAAC;QACV;MACJ;IACJ;;IAED,OAAOtC,WAAW,CACd,IAAI,CAACoC,kCAAkC,CAAClC,IAAI,CAAC,IAAI,CAAC,EAClDR,iBAAiB,CAAC2C,oDAAoD,EACtE,IAAI,CAACjC,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CAACN,OAAO,EAAE,KAAK,CAAC;;EAGrB;;;AAGG;EACK,MAAM8C,kCAAkCA,CAC5C9C,OAAgC,EAChC2D,IAAa;IAAA,IAAAC,sBAAA;IAEb,CAAAA,sBAAA,OAAI,CAAC9D,iBAAiB,cAAA8D,sBAAA,eAAtBA,sBAAA,CAAwBzD,mBAAmB,CACvCC,iBAAiB,CAAC2C,oDAAoD,EACtE/C,OAAO,CAACM,aAAa,CACxB;;IAGD,MAAMuD,YAAY,GAAGC,MAAM,CACvB,IAAI,CAACrC,YAAY,CAACsC,eAAe,CAACnD,IAAI,CAAC,IAAI,CAACa,YAAY,CAAC,EACzDrB,iBAAiB,CAAC4D,2BAA2B,EAC7C,IAAI,CAAClD,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CACGN,OAAO,CAACwC,OAAO,EACfmB,IAAI,EACJ3D,OAAO,CAACM,aAAa,EACrB2B,SAAS,EACT,IAAI,CAACnC,iBAAiB,CACzB;IAED,IAAI,CAAC+D,YAAY,EAAE;MACf,MAAMI,kCAAkC,CACpCb,aAA+C,CAClD;IACJ;IAED,IACIS,YAAY,CAACK,SAAS,IACtBC,cAAwB,CACpBN,YAAY,CAACK,SAAS,EACtBlE,OAAO,CAACoE,mCAAmC,IACvC3E,+CAA+C,CACtD,EACH;MAAA,IAAA4E,sBAAA;MACE,CAAAA,sBAAA,OAAI,CAACvE,iBAAiB,cAAAuE,sBAAA,eAAtBA,sBAAA,CAAwBC,SAAS,CAC7B;QAAEC,aAAa,EAAEC,MAAM,CAACX,YAAY,CAACK,SAAS;MAAC,CAAE,EACjDlE,OAAO,CAACM,aAAa,CACxB;MACD,MAAM2D,kCAAkC,CACpCQ,mBAAqD,CACxD;IACJ;;IAGD,MAAMC,mBAAmB,GAAAC,aAAA,CAAAA,aAAA,KAClB3E,OAAO;MACV6D,YAAY,EAAEA,YAAY,CAACe,MAAM;MACjCC,oBAAoB,EAChB7E,OAAO,CAAC6E,oBAAoB,IAAIC,oBAAoB,CAACC,MAAM;MAC/DC,aAAa,EAAE;QACXC,UAAU,EAAEjF,OAAO,CAACwC,OAAO,CAAC0C,aAAa;QACzCC,IAAI,EAAEC,iBAAiB,CAACC;MAC3B;IAAA,EACJ;IAED,IAAI;MACA,OAAO,MAAM3E,WAAW,CACpB,IAAI,CAACX,YAAY,CAACa,IAAI,CAAC,IAAI,CAAC,EAC5BR,iBAAiB,CAACC,8BAA8B,EAChD,IAAI,CAACS,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CAACoE,mBAAmB,CAAC;IACzB,EAAC,OAAO1B,CAAC,EAAE;MACR,IAAIA,CAAC,YAAYE,4BAA4B,EAAE;QAAA,IAAAoC,sBAAA;QAC3C,CAAAA,sBAAA,OAAI,CAACxF,iBAAiB,cAAAwF,sBAAA,eAAtBA,sBAAA,CAAwBhB,SAAS,CAC7B;UAAEC,aAAa,EAAEC,MAAM,CAACX,YAAY,CAACK,SAAS;QAAC,CAAE,EACjDlE,OAAO,CAACM,aAAa,CACxB;QAED,IAAI0C,CAAC,CAACS,QAAQ,KAAK8B,QAA0C,EAAE;;UAE3D,IAAI,CAACzE,MAAM,CAAC0E,OAAO,CACf,sEAAsE,CACzE;UACD,MAAMC,kBAAkB,GACpB,IAAI,CAAChE,YAAY,CAACiE,qBAAqB,CAAC7B,YAAY,CAAC;UACzD,IAAI,CAACpC,YAAY,CAACkE,kBAAkB,CAChCF,kBAAkB,EAClBzF,OAAO,CAACM,aAAa,CACxB;QACJ;MACJ;MAED,MAAM0C,CAAC;IACV;;EAGL;;;;AAIG;EACK,MAAMrC,mBAAmBA,CAC7BX,OAAkC,EAClCe,SAAoB;IAAA,IAAA6E,sBAAA;IAEpB,CAAAA,sBAAA,OAAI,CAAC9F,iBAAiB,cAAA8F,sBAAA,eAAtBA,sBAAA,CAAwBzF,mBAAmB,CACvCC,iBAAiB,CAACS,qCAAqC,EACvDb,OAAO,CAACM,aAAa,CACxB;IAED,MAAMuF,qBAAqB,GAAG,IAAI,CAACC,0BAA0B,CAAC9F,OAAO,CAAC;IACtE,MAAM+F,QAAQ,GAAGC,SAAS,CAACC,iBAAiB,CACxClF,SAAS,CAACmF,aAAa,EACvBL,qBAAqB,CACxB;IAED,MAAMM,WAAW,GAAG,MAAMzF,WAAW,CACjC,IAAI,CAAC0F,sBAAsB,CAACxF,IAAI,CAAC,IAAI,CAAC,EACtCR,iBAAiB,CAACiG,wCAAwC,EAC1D,IAAI,CAACvF,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CAACN,OAAO,CAAC;IACV,MAAMiB,OAAO,GAA2B,IAAI,CAACqF,yBAAyB,CAClEtG,OAAO,CAACgF,aAAa,CACxB;IAED,MAAMuB,UAAU,GAAGC,oBAAoB,CACnC,IAAI,CAAClF,MAAM,CAACC,WAAW,CAACC,QAAQ,EAChCxB,OAAO,CACV;IAED,OAAOU,WAAW,CACd,IAAI,CAAC+F,0BAA0B,CAAC7F,IAAI,CAAC,IAAI,CAAC,EAC1CR,iBAAiB,CAACsG,4CAA4C,EAC9D,IAAI,CAAC5F,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CACGyF,QAAQ,EACRI,WAAW,EACXlF,OAAO,EACPsF,UAAU,EACVvG,OAAO,CAACM,aAAa,EACrBF,iBAAiB,CAACsG,4CAA4C,CACjE;;EAGL;;;AAGG;EACK,MAAMN,sBAAsBA,CAChCpG,OAAkC;IAAA,IAAA2G,sBAAA,EAAAC,qBAAA,EAAAC,qBAAA;IAElC,CAAAF,sBAAA,OAAI,CAAC7G,iBAAiB,cAAA6G,sBAAA,eAAtBA,sBAAA,CAAwBxG,mBAAmB,CACvCC,iBAAiB,CAACiG,wCAAwC,EAC1DrG,OAAO,CAACM,aAAa,CACxB;IAED,MAAMwG,UAAU,GAAG,IAAIC,GAAG,EAAkB;IAE5CC,WAAmC,CAC/BF,UAAU,EACV9G,OAAO,CAACiH,gBAAgB,MAAAL,qBAAA,GACpB5G,OAAO,CAACkH,mBAAmB,cAAAN,qBAAA,uBAA3BA,qBAAA,CAA8BO,SAA4B,CAAC,KAC3D,IAAI,CAAC7F,MAAM,CAACC,WAAW,CAACC,QAAQ,CACvC;IAED,IAAIxB,OAAO,CAACoH,WAAW,EAAE;MACrBC,cAAsC,CAClCP,UAAU,EACV9G,OAAO,CAACoH,WAAW,CACtB;IACJ;IAEDE,SAAiC,CAC7BR,UAAU,EACV9G,OAAO,CAACuH,MAAM,EACd,IAAI,GAAAV,qBAAA,GACJ,IAAI,CAACvF,MAAM,CAACC,WAAW,CAACR,SAAS,CAACyG,OAAO,CAACC,WAAW,cAAAZ,qBAAA,uBAArDA,qBAAA,CAAuDa,aAAa,CACvE;IAEDC,YAAoC,CAChCb,UAAU,EACVc,SAAS,CAACC,mBAAmB,CAChC;IAEDC,aAAqC,CAAChB,UAAU,CAAC;IAEjDiB,cAAsC,CAClCjB,UAAU,EACV,IAAI,CAACxF,MAAM,CAAC0G,WAAW,CAC1B;IACDC,uBAA+C,CAC3CnB,UAAU,EACV,IAAI,CAACxF,MAAM,CAAC4G,SAAS,CAACC,WAAW,CACpC;IACDC,aAAqC,CAACtB,UAAU,CAAC;IAEjD,IAAI,IAAI,CAACuB,sBAAsB,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAChH,MAAM,CAAC,EAAE;MACjEiH,kBAA0C,CACtCzB,UAAU,EACV,IAAI,CAACuB,sBAAsB,CAC9B;IACJ;IAEDG,eAAuC,CACnC1B,UAAU,EACV9G,OAAO,CAAC6D,YAAY,CACvB;IAED,IAAI,IAAI,CAACvC,MAAM,CAACmH,iBAAiB,CAACC,YAAY,EAAE;MAC5CC,eAAuC,CACnC7B,UAAU,EACV,IAAI,CAACxF,MAAM,CAACmH,iBAAiB,CAACC,YAAY,CAC7C;IACJ;IAED,IAAI,IAAI,CAACpH,MAAM,CAACmH,iBAAiB,CAACG,eAAe,EAAE;MAC/C,MAAMA,eAAe,GACjB,IAAI,CAACtH,MAAM,CAACmH,iBAAiB,CAACG,eAAe;MAEjDC,kBAA0C,CACtC/B,UAAU,EACV,MAAMgC,kBAAkB,CACpBF,eAAe,CAACG,SAAS,EACzB,IAAI,CAACzH,MAAM,CAACC,WAAW,CAACC,QAAQ,EAChCxB,OAAO,CAACgJ,kBAAkB,CAC7B,CACJ;MACDC,sBAA8C,CAC1CnC,UAAU,EACV8B,eAAe,CAACM,aAAa,CAChC;IACJ;IAED,IAAIlJ,OAAO,CAAC6E,oBAAoB,KAAKC,oBAAoB,CAACqE,GAAG,EAAE;MAC3D,MAAMC,iBAAiB,GAAG,IAAIC,iBAAiB,CAC3C,IAAI,CAAC3H,WAAW,EAChB,IAAI,CAAC5B,iBAAiB,CACzB;MAED,IAAIwJ,UAAU;MACd,IAAI,CAACtJ,OAAO,CAACuJ,MAAM,EAAE;QACjB,MAAMC,mBAAmB,GAAG,MAAM9I,WAAW,CACzC0I,iBAAiB,CAACK,WAAW,CAAC7I,IAAI,CAACwI,iBAAiB,CAAC,EACrDhJ,iBAAiB,CAACsJ,mBAAmB,EACrC,IAAI,CAAC5I,MAAM,EACX,IAAI,CAAChB,iBAAiB,EACtBE,OAAO,CAACM,aAAa,CACxB,CAACN,OAAO,EAAE,IAAI,CAACc,MAAM,CAAC;QAEvBwI,UAAU,GAAGE,mBAAmB,CAACG,YAAY;MAChD,OAAM;QACHL,UAAU,GAAG,IAAI,CAAC5H,WAAW,CAACkI,SAAS,CAAC5J,OAAO,CAACuJ,MAAM,CAAC;MAC1D;;MAGDM,WAAmC,CAAC/C,UAAU,EAAEwC,UAAU,CAAC;IAC9D,OAAM,IAAItJ,OAAO,CAAC6E,oBAAoB,KAAKC,oBAAoB,CAACgF,GAAG,EAAE;MAClE,IAAI9J,OAAO,CAAC+J,MAAM,EAAE;QAChBC,SAAiC,CAAClD,UAAU,EAAE9G,OAAO,CAAC+J,MAAM,CAAC;MAChE,OAAM;QACH,MAAM1H,8BAA8B,CAChC4H,aAA2C,CAC9C;MACJ;IACJ;IAED,IACI,CAACC,WAAW,CAACC,UAAU,CAACnK,OAAO,CAACoK,MAAM,CAAC,IACtC,IAAI,CAAC9I,MAAM,CAACC,WAAW,CAAC8I,kBAAkB,IACvC,IAAI,CAAC/I,MAAM,CAACC,WAAW,CAAC8I,kBAAkB,CAACC,MAAM,GAAG,CAAE,EAC5D;MACEC,SAAiC,CAC7BzD,UAAU,EACV9G,OAAO,CAACoK,MAAM,EACd,IAAI,CAAC9I,MAAM,CAACC,WAAW,CAAC8I,kBAAkB,CAC7C;IACJ;IAED,IACI,IAAI,CAAC/I,MAAM,CAACkJ,aAAa,CAACC,oBAAoB,IAC9CzK,OAAO,CAACgF,aAAa,EACvB;MACE,QAAQhF,OAAO,CAACgF,aAAa,CAACG,IAAI;QAC9B,KAAKC,iBAAiB,CAACC,eAAe;UAClC,IAAI;YACA,MAAMqF,UAAU,GAAGC,gCAAgC,CAC/C3K,OAAO,CAACgF,aAAa,CAACC,UAAU,CACnC;YACD2F,SAAiC,CAC7B9D,UAAU,EACV4D,UAAU,CACb;UACJ,EAAC,OAAO1H,CAAC,EAAE;YACR,IAAI,CAAClC,MAAM,CAAC0E,OAAO,CACf,kDAAkD,GAC9CxC,CAAC,CACR;UACJ;UACD;QACJ,KAAKoC,iBAAiB,CAACyF,GAAG;UACtBC,SAAiC,CAC7BhE,UAAU,EACV9G,OAAO,CAACgF,aAAa,CAACC,UAAU,CACnC;UACD;MACP;IACJ;IAED,IAAIjF,OAAO,CAACiH,gBAAgB,EAAE;MAC1B8D,mBAA2C,CACvCjE,UAAU,EACV,IAAI,CAACxF,MAAM,CAACC,WAAW,CAACC,QAAQ,EAChC,IAAI,CAACF,MAAM,CAACC,WAAW,CAAC6F,WAAW,CACtC;IACJ;IAED,IAAIpH,OAAO,CAACkH,mBAAmB,EAAE;MAC7B8D,uBAA+C,CAC3ClE,UAAU,EACV9G,OAAO,CAACkH,mBAAmB,CAC9B;IACJ;IAED+D,sBAA8C,CAC1CnE,UAAU,EACV9G,OAAO,CAACM,aAAa,EACrB,IAAI,CAACR,iBAAiB,CACzB;IACD,OAAOoL,gBAAyB,CAACpE,UAAU,CAAC;;AAEnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}