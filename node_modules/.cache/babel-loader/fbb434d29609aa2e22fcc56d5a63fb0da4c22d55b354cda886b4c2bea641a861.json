{"ast":null,"code":"/*! @azure/msal-common v15.13.0 2025-09-24 */\n'use strict';\n\nimport { extractTokenClaims } from '../../account/AuthToken.mjs';\nimport { createClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { CredentialType, AuthenticationScheme, SERVER_TELEM_CONSTANTS, ThrottlingConstants, APP_METADATA, Separators, AUTHORITY_METADATA_CONSTANTS } from '../../utils/Constants.mjs';\nimport { nowSeconds } from '../../utils/TimeUtils.mjs';\nimport { tokenClaimsCnfRequiredForSignedJwt } from '../../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Create IdTokenEntity\r\n * @param homeAccountId\r\n * @param authenticationResult\r\n * @param clientId\r\n * @param authority\r\n */\nfunction createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {\n  const idTokenEntity = {\n    credentialType: CredentialType.ID_TOKEN,\n    homeAccountId: homeAccountId,\n    environment: environment,\n    clientId: clientId,\n    secret: idToken,\n    realm: tenantId,\n    lastUpdatedAt: Date.now().toString() // Set the last updated time to now\n  };\n  return idTokenEntity;\n}\n/**\r\n * Create AccessTokenEntity\r\n * @param homeAccountId\r\n * @param environment\r\n * @param accessToken\r\n * @param clientId\r\n * @param tenantId\r\n * @param scopes\r\n * @param expiresOn\r\n * @param extExpiresOn\r\n */\nfunction createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n  var _atEntity$tokenType, _tokenClaims$cnf;\n  const atEntity = {\n    homeAccountId: homeAccountId,\n    credentialType: CredentialType.ACCESS_TOKEN,\n    secret: accessToken,\n    cachedAt: nowSeconds().toString(),\n    expiresOn: expiresOn.toString(),\n    extendedExpiresOn: extExpiresOn.toString(),\n    environment: environment,\n    clientId: clientId,\n    realm: tenantId,\n    target: scopes,\n    tokenType: tokenType || AuthenticationScheme.BEARER,\n    lastUpdatedAt: Date.now().toString() // Set the last updated time to now\n  };\n  if (userAssertionHash) {\n    atEntity.userAssertionHash = userAssertionHash;\n  }\n  if (refreshOn) {\n    atEntity.refreshOn = refreshOn.toString();\n  }\n  if (requestedClaims) {\n    atEntity.requestedClaims = requestedClaims;\n    atEntity.requestedClaimsHash = requestedClaimsHash;\n  }\n  /*\r\n   * Create Access Token With Auth Scheme instead of regular access token\r\n   * Cast to lower to handle \"bearer\" from ADFS\r\n   */\n  if (((_atEntity$tokenType = atEntity.tokenType) === null || _atEntity$tokenType === void 0 ? void 0 : _atEntity$tokenType.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    switch (atEntity.tokenType) {\n      case AuthenticationScheme.POP:\n        // Make sure keyId is present and add it to credential\n        const tokenClaims = extractTokenClaims(accessToken, base64Decode);\n        if (!(tokenClaims !== null && tokenClaims !== void 0 && (_tokenClaims$cnf = tokenClaims.cnf) !== null && _tokenClaims$cnf !== void 0 && _tokenClaims$cnf.kid)) {\n          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);\n        }\n        atEntity.keyId = tokenClaims.cnf.kid;\n        break;\n      case AuthenticationScheme.SSH:\n        atEntity.keyId = keyId;\n    }\n  }\n  return atEntity;\n}\n/**\r\n * Create RefreshTokenEntity\r\n * @param homeAccountId\r\n * @param authenticationResult\r\n * @param clientId\r\n * @param authority\r\n */\nfunction createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {\n  const rtEntity = {\n    credentialType: CredentialType.REFRESH_TOKEN,\n    homeAccountId: homeAccountId,\n    environment: environment,\n    clientId: clientId,\n    secret: refreshToken,\n    lastUpdatedAt: Date.now().toString()\n  };\n  if (userAssertionHash) {\n    rtEntity.userAssertionHash = userAssertionHash;\n  }\n  if (familyId) {\n    rtEntity.familyId = familyId;\n  }\n  if (expiresOn) {\n    rtEntity.expiresOn = expiresOn.toString();\n  }\n  return rtEntity;\n}\nfunction isCredentialEntity(entity) {\n  return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\");\n}\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\nfunction isAccessTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n}\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\nfunction isIdTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity.hasOwnProperty(\"realm\") && entity[\"credentialType\"] === CredentialType.ID_TOKEN;\n}\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\nfunction isRefreshTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity[\"credentialType\"] === CredentialType.REFRESH_TOKEN;\n}\n/**\r\n * validates if a given cache entry is \"Telemetry\", parses <key,value>\r\n * @param key\r\n * @param entity\r\n */\nfunction isServerTelemetryEntity(key, entity) {\n  const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;\n  let validateEntity = true;\n  if (entity) {\n    validateEntity = entity.hasOwnProperty(\"failedRequests\") && entity.hasOwnProperty(\"errors\") && entity.hasOwnProperty(\"cacheHits\");\n  }\n  return validateKey && validateEntity;\n}\n/**\r\n * validates if a given cache entry is \"Throttling\", parses <key,value>\r\n * @param key\r\n * @param entity\r\n */\nfunction isThrottlingEntity(key, entity) {\n  let validateKey = false;\n  if (key) {\n    validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;\n  }\n  let validateEntity = true;\n  if (entity) {\n    validateEntity = entity.hasOwnProperty(\"throttleTime\");\n  }\n  return validateKey && validateEntity;\n}\n/**\r\n * Generate AppMetadata Cache Key as per the schema: appmetadata-<environment>-<client_id>\r\n */\nfunction generateAppMetadataKey(_ref) {\n  let {\n    environment,\n    clientId\n  } = _ref;\n  const appMetaDataKeyArray = [APP_METADATA, environment, clientId];\n  return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n/*\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\nfunction isAppMetadataEntity(key, entity) {\n  if (!entity) {\n    return false;\n  }\n  return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"environment\");\n}\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\nfunction isAuthorityMetadataEntity(key, entity) {\n  if (!entity) {\n    return false;\n  }\n  return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty(\"aliases\") && entity.hasOwnProperty(\"preferred_cache\") && entity.hasOwnProperty(\"preferred_network\") && entity.hasOwnProperty(\"canonical_authority\") && entity.hasOwnProperty(\"authorization_endpoint\") && entity.hasOwnProperty(\"token_endpoint\") && entity.hasOwnProperty(\"issuer\") && entity.hasOwnProperty(\"aliasesFromNetwork\") && entity.hasOwnProperty(\"endpointsFromNetwork\") && entity.hasOwnProperty(\"expiresAt\") && entity.hasOwnProperty(\"jwks_uri\");\n}\n/**\r\n * Reset the exiresAt value\r\n */\nfunction generateAuthorityMetadataExpiresAt() {\n  return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;\n}\nfunction updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {\n  authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;\n  authorityMetadata.token_endpoint = updatedValues.token_endpoint;\n  authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;\n  authorityMetadata.issuer = updatedValues.issuer;\n  authorityMetadata.endpointsFromNetwork = fromNetwork;\n  authorityMetadata.jwks_uri = updatedValues.jwks_uri;\n}\nfunction updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {\n  authorityMetadata.aliases = updatedValues.aliases;\n  authorityMetadata.preferred_cache = updatedValues.preferred_cache;\n  authorityMetadata.preferred_network = updatedValues.preferred_network;\n  authorityMetadata.aliasesFromNetwork = fromNetwork;\n}\n/**\r\n * Returns whether or not the data needs to be refreshed\r\n */\nfunction isAuthorityMetadataExpired(metadata) {\n  return metadata.expiresAt <= nowSeconds();\n}\nexport { createAccessTokenEntity, createIdTokenEntity, createRefreshTokenEntity, generateAppMetadataKey, generateAuthorityMetadataExpiresAt, isAccessTokenEntity, isAppMetadataEntity, isAuthorityMetadataEntity, isAuthorityMetadataExpired, isCredentialEntity, isIdTokenEntity, isRefreshTokenEntity, isServerTelemetryEntity, isThrottlingEntity, updateAuthorityEndpointMetadata, updateCloudDiscoveryMetadata };","map":{"version":3,"names":["createIdTokenEntity","homeAccountId","environment","idToken","clientId","tenantId","idTokenEntity","credentialType","CredentialType","ID_TOKEN","secret","realm","lastUpdatedAt","Date","now","toString","createAccessTokenEntity","accessToken","scopes","expiresOn","extExpiresOn","base64Decode","refreshOn","tokenType","userAssertionHash","keyId","requestedClaims","requestedClaimsHash","_atEntity$tokenType","_tokenClaims$cnf","atEntity","ACCESS_TOKEN","cachedAt","nowSeconds","extendedExpiresOn","target","AuthenticationScheme","BEARER","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","POP","tokenClaims","extractTokenClaims","cnf","kid","createClientAuthError","tokenClaimsCnfRequiredForSignedJwt","SSH","createRefreshTokenEntity","refreshToken","familyId","rtEntity","REFRESH_TOKEN","isCredentialEntity","entity","hasOwnProperty","isAccessTokenEntity","isIdTokenEntity","isRefreshTokenEntity","isServerTelemetryEntity","key","validateKey","indexOf","SERVER_TELEM_CONSTANTS","CACHE_KEY","validateEntity","isThrottlingEntity","ThrottlingConstants","THROTTLING_PREFIX","generateAppMetadataKey","_ref","appMetaDataKeyArray","APP_METADATA","join","Separators","CACHE_KEY_SEPARATOR","isAppMetadataEntity","isAuthorityMetadataEntity","AUTHORITY_METADATA_CONSTANTS","generateAuthorityMetadataExpiresAt","REFRESH_TIME_SECONDS","updateAuthorityEndpointMetadata","authorityMetadata","updatedValues","fromNetwork","authorization_endpoint","token_endpoint","end_session_endpoint","issuer","endpointsFromNetwork","jwks_uri","updateCloudDiscoveryMetadata","aliases","preferred_cache","preferred_network","aliasesFromNetwork","isAuthorityMetadataExpired","metadata","expiresAt"],"sources":["C:\\_Projects\\DGL_ToDo\\react_todo_dashboard2\\node_modules\\@azure\\msal-common\\src\\cache\\utils\\CacheHelpers.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { extractTokenClaims } from \"../../account/AuthToken.js\";\nimport { TokenClaims } from \"../../account/TokenClaims.js\";\nimport { CloudDiscoveryMetadata } from \"../../authority/CloudDiscoveryMetadata.js\";\nimport { OpenIdConfigResponse } from \"../../authority/OpenIdConfigResponse.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../../error/ClientAuthError.js\";\nimport {\n    APP_METADATA,\n    AUTHORITY_METADATA_CONSTANTS,\n    AuthenticationScheme,\n    CredentialType,\n    SERVER_TELEM_CONSTANTS,\n    Separators,\n    ThrottlingConstants,\n} from \"../../utils/Constants.js\";\nimport * as TimeUtils from \"../../utils/TimeUtils.js\";\nimport { AccessTokenEntity } from \"../entities/AccessTokenEntity.js\";\nimport { AppMetadataEntity } from \"../entities/AppMetadataEntity.js\";\nimport { AuthorityMetadataEntity } from \"../entities/AuthorityMetadataEntity.js\";\nimport { CredentialEntity } from \"../entities/CredentialEntity.js\";\nimport { IdTokenEntity } from \"../entities/IdTokenEntity.js\";\nimport { RefreshTokenEntity } from \"../entities/RefreshTokenEntity.js\";\n\n/**\n * Create IdTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nexport function createIdTokenEntity(\n    homeAccountId: string,\n    environment: string,\n    idToken: string,\n    clientId: string,\n    tenantId: string\n): IdTokenEntity {\n    const idTokenEntity: IdTokenEntity = {\n        credentialType: CredentialType.ID_TOKEN,\n        homeAccountId: homeAccountId,\n        environment: environment,\n        clientId: clientId,\n        secret: idToken,\n        realm: tenantId,\n        lastUpdatedAt: Date.now().toString(), // Set the last updated time to now\n    };\n\n    return idTokenEntity;\n}\n\n/**\n * Create AccessTokenEntity\n * @param homeAccountId\n * @param environment\n * @param accessToken\n * @param clientId\n * @param tenantId\n * @param scopes\n * @param expiresOn\n * @param extExpiresOn\n */\nexport function createAccessTokenEntity(\n    homeAccountId: string,\n    environment: string,\n    accessToken: string,\n    clientId: string,\n    tenantId: string,\n    scopes: string,\n    expiresOn: number,\n    extExpiresOn: number,\n    base64Decode: (input: string) => string,\n    refreshOn?: number,\n    tokenType?: AuthenticationScheme,\n    userAssertionHash?: string,\n    keyId?: string,\n    requestedClaims?: string,\n    requestedClaimsHash?: string\n): AccessTokenEntity {\n    const atEntity: AccessTokenEntity = {\n        homeAccountId: homeAccountId,\n        credentialType: CredentialType.ACCESS_TOKEN,\n        secret: accessToken,\n        cachedAt: TimeUtils.nowSeconds().toString(),\n        expiresOn: expiresOn.toString(),\n        extendedExpiresOn: extExpiresOn.toString(),\n        environment: environment,\n        clientId: clientId,\n        realm: tenantId,\n        target: scopes,\n        tokenType: tokenType || AuthenticationScheme.BEARER,\n        lastUpdatedAt: Date.now().toString(), // Set the last updated time to now\n    };\n\n    if (userAssertionHash) {\n        atEntity.userAssertionHash = userAssertionHash;\n    }\n\n    if (refreshOn) {\n        atEntity.refreshOn = refreshOn.toString();\n    }\n\n    if (requestedClaims) {\n        atEntity.requestedClaims = requestedClaims;\n        atEntity.requestedClaimsHash = requestedClaimsHash;\n    }\n\n    /*\n     * Create Access Token With Auth Scheme instead of regular access token\n     * Cast to lower to handle \"bearer\" from ADFS\n     */\n    if (\n        atEntity.tokenType?.toLowerCase() !==\n        AuthenticationScheme.BEARER.toLowerCase()\n    ) {\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n        switch (atEntity.tokenType) {\n            case AuthenticationScheme.POP:\n                // Make sure keyId is present and add it to credential\n                const tokenClaims: TokenClaims | null = extractTokenClaims(\n                    accessToken,\n                    base64Decode\n                );\n                if (!tokenClaims?.cnf?.kid) {\n                    throw createClientAuthError(\n                        ClientAuthErrorCodes.tokenClaimsCnfRequiredForSignedJwt\n                    );\n                }\n                atEntity.keyId = tokenClaims.cnf.kid;\n                break;\n            case AuthenticationScheme.SSH:\n                atEntity.keyId = keyId;\n        }\n    }\n\n    return atEntity;\n}\n\n/**\n * Create RefreshTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nexport function createRefreshTokenEntity(\n    homeAccountId: string,\n    environment: string,\n    refreshToken: string,\n    clientId: string,\n    familyId?: string,\n    userAssertionHash?: string,\n    expiresOn?: number\n): RefreshTokenEntity {\n    const rtEntity: RefreshTokenEntity = {\n        credentialType: CredentialType.REFRESH_TOKEN,\n        homeAccountId: homeAccountId,\n        environment: environment,\n        clientId: clientId,\n        secret: refreshToken,\n        lastUpdatedAt: Date.now().toString(),\n    };\n\n    if (userAssertionHash) {\n        rtEntity.userAssertionHash = userAssertionHash;\n    }\n\n    if (familyId) {\n        rtEntity.familyId = familyId;\n    }\n\n    if (expiresOn) {\n        rtEntity.expiresOn = expiresOn.toString();\n    }\n\n    return rtEntity;\n}\n\nexport function isCredentialEntity(entity: object): entity is CredentialEntity {\n    return (\n        entity.hasOwnProperty(\"homeAccountId\") &&\n        entity.hasOwnProperty(\"environment\") &&\n        entity.hasOwnProperty(\"credentialType\") &&\n        entity.hasOwnProperty(\"clientId\") &&\n        entity.hasOwnProperty(\"secret\")\n    );\n}\n\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isAccessTokenEntity(\n    entity: object\n): entity is AccessTokenEntity {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        isCredentialEntity(entity) &&\n        entity.hasOwnProperty(\"realm\") &&\n        entity.hasOwnProperty(\"target\") &&\n        (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN ||\n            entity[\"credentialType\"] ===\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME)\n    );\n}\n\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isIdTokenEntity(entity: object): entity is IdTokenEntity {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        isCredentialEntity(entity) &&\n        entity.hasOwnProperty(\"realm\") &&\n        entity[\"credentialType\"] === CredentialType.ID_TOKEN\n    );\n}\n\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isRefreshTokenEntity(\n    entity: object\n): entity is RefreshTokenEntity {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        isCredentialEntity(entity) &&\n        entity[\"credentialType\"] === CredentialType.REFRESH_TOKEN\n    );\n}\n\n/**\n * validates if a given cache entry is \"Telemetry\", parses <key,value>\n * @param key\n * @param entity\n */\nexport function isServerTelemetryEntity(key: string, entity?: object): boolean {\n    const validateKey: boolean =\n        key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;\n    let validateEntity: boolean = true;\n\n    if (entity) {\n        validateEntity =\n            entity.hasOwnProperty(\"failedRequests\") &&\n            entity.hasOwnProperty(\"errors\") &&\n            entity.hasOwnProperty(\"cacheHits\");\n    }\n\n    return validateKey && validateEntity;\n}\n\n/**\n * validates if a given cache entry is \"Throttling\", parses <key,value>\n * @param key\n * @param entity\n */\nexport function isThrottlingEntity(key: string, entity?: object): boolean {\n    let validateKey: boolean = false;\n    if (key) {\n        validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;\n    }\n\n    let validateEntity: boolean = true;\n    if (entity) {\n        validateEntity = entity.hasOwnProperty(\"throttleTime\");\n    }\n\n    return validateKey && validateEntity;\n}\n\n/**\n * Generate AppMetadata Cache Key as per the schema: appmetadata-<environment>-<client_id>\n */\nexport function generateAppMetadataKey({\n    environment,\n    clientId,\n}: AppMetadataEntity): string {\n    const appMetaDataKeyArray: Array<string> = [\n        APP_METADATA,\n        environment,\n        clientId,\n    ];\n    return appMetaDataKeyArray\n        .join(Separators.CACHE_KEY_SEPARATOR)\n        .toLowerCase();\n}\n\n/*\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isAppMetadataEntity(key: string, entity: object): boolean {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        key.indexOf(APP_METADATA) === 0 &&\n        entity.hasOwnProperty(\"clientId\") &&\n        entity.hasOwnProperty(\"environment\")\n    );\n}\n\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isAuthorityMetadataEntity(\n    key: string,\n    entity: object\n): boolean {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 &&\n        entity.hasOwnProperty(\"aliases\") &&\n        entity.hasOwnProperty(\"preferred_cache\") &&\n        entity.hasOwnProperty(\"preferred_network\") &&\n        entity.hasOwnProperty(\"canonical_authority\") &&\n        entity.hasOwnProperty(\"authorization_endpoint\") &&\n        entity.hasOwnProperty(\"token_endpoint\") &&\n        entity.hasOwnProperty(\"issuer\") &&\n        entity.hasOwnProperty(\"aliasesFromNetwork\") &&\n        entity.hasOwnProperty(\"endpointsFromNetwork\") &&\n        entity.hasOwnProperty(\"expiresAt\") &&\n        entity.hasOwnProperty(\"jwks_uri\")\n    );\n}\n\n/**\n * Reset the exiresAt value\n */\nexport function generateAuthorityMetadataExpiresAt(): number {\n    return (\n        TimeUtils.nowSeconds() +\n        AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS\n    );\n}\n\nexport function updateAuthorityEndpointMetadata(\n    authorityMetadata: AuthorityMetadataEntity,\n    updatedValues: OpenIdConfigResponse,\n    fromNetwork: boolean\n): void {\n    authorityMetadata.authorization_endpoint =\n        updatedValues.authorization_endpoint;\n    authorityMetadata.token_endpoint = updatedValues.token_endpoint;\n    authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;\n    authorityMetadata.issuer = updatedValues.issuer;\n    authorityMetadata.endpointsFromNetwork = fromNetwork;\n    authorityMetadata.jwks_uri = updatedValues.jwks_uri;\n}\n\nexport function updateCloudDiscoveryMetadata(\n    authorityMetadata: AuthorityMetadataEntity,\n    updatedValues: CloudDiscoveryMetadata,\n    fromNetwork: boolean\n): void {\n    authorityMetadata.aliases = updatedValues.aliases;\n    authorityMetadata.preferred_cache = updatedValues.preferred_cache;\n    authorityMetadata.preferred_network = updatedValues.preferred_network;\n    authorityMetadata.aliasesFromNetwork = fromNetwork;\n}\n\n/**\n * Returns whether or not the data needs to be refreshed\n */\nexport function isAuthorityMetadataExpired(\n    metadata: AuthorityMetadataEntity\n): boolean {\n    return metadata.expiresAt <= TimeUtils.nowSeconds();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}